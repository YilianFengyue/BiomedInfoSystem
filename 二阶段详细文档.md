# 生物医药数字信息系统 - 二阶段项目计划书

## 一、项目概述

### 1.1 项目目标

基于一阶段"中药材地理信息管理系统+在线教学平台"的基础，拓展构建集成中医药知识图谱、方剂管理、科研文献挖掘、教学科研一体化的综合性中医药数字信息平台。

### 1.2 核心创新点

- **中医药知识图谱**：构建"疾病-证候-症状-方剂-药材"语义关联网络
- **AI科研助手**：实用型AI Agent，结合业务场景的智能问答与研究支持
- **多模态数据融合**：地理信息、教学资源、科研文献、临床数据一体化
- **跨端协同**：Web、移动端、桌面端统一体验

### 1.3 技术架构

- **后端**：SpringBoot + MyBatisPlus + MySQL + Neo4j(图数据库)
- **前端**：Vue3 + Vuetify3 + ECharts + D3.js
- **移动端**：Flutter
- **桌面端**：Electron
- **AI集成**：大语言模型API + 向量数据库
- **部署**：Docker + Linux + OSS云存储

------

## 二、功能模块设计与实现

### 模块一：中医药知识图谱系统

#### 2.1.1 功能需求

- **核心实体**：疾病、证候、症状、方剂、药材、经络、穴位
- **关系类型**：治疗关系、组成关系、归经关系、配伍关系、禁忌关系
- **应用功能**：知识检索、关系探索、智能推荐、可视化展示

#### 2.1.2 技术实现方案

**后端设计（SpringBoot）**：

```java
// 核心依赖
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-data-neo4j</artifactId>
</dependency>
<dependency>
    <groupId>org.neo4j</groupId>
    <artifactId>neo4j-ogm-spring-boot-starter</artifactId>
</dependency>
```

**实体类设计**：

```java
@Node("Herb")
public class HerbNode {
    @Id @GeneratedValue
    private Long id;
    private String name;           // 药材名称
    private String pinyin;         // 拼音
    private String alias;          // 别名
    private String nature;         // 性味
    private String meridian;       // 归经
    private String effect;         // 功效
    private String usage;          // 用法用量
    private String taboo;          // 禁忌
    
    @Relationship(type = "TREATS", direction = Relationship.OUTGOING)
    private Set<DiseaseNode> treatedDiseases;
    
    @Relationship(type = "COMPOSES", direction = Relationship.INCOMING)
    private Set<FormulaNode> formulas;
}

@Node("Formula")
public class FormulaNode {
    @Id @GeneratedValue
    private Long id;
    private String name;           // 方剂名称
    private String source;         // 出处
    private String composition;    // 组成
    private String usage;          // 用法
    private String function;       // 功用
    private String indication;     // 主治
    
    @Relationship(type = "CONTAINS", direction = Relationship.OUTGOING)
    private Set<HerbComponent> herbComponents;
}

@RelationshipProperties
public class HerbComponent {
    @Id @GeneratedValue
    private Long id;
    private String dosage;         // 用量
    private String role;           // 配伍作用（君臣佐使）
    
    @StartNode
    private FormulaNode formula;
    
    @EndNode
    private HerbNode herb;
}
```

**图谱查询服务**：

```java
@Service
public class KnowledgeGraphService {
    
    @Autowired
    private Neo4jTemplate neo4jTemplate;
    
    // 查询某疾病的治疗方剂
    public List<FormulaNode> findTreatmentFormulas(String diseaseName) {
        String cypher = """
            MATCH (d:Disease {name: $diseaseName})-[:TREATED_BY]->(f:Formula)
            RETURN f ORDER BY f.popularity DESC LIMIT 10
            """;
        return neo4jTemplate.findAll(cypher, Map.of("diseaseName", diseaseName), FormulaNode.class);
    }
    
    // 查询药材配伍规律
    public List<Map<String, Object>> findHerbCombinations(String herbName) {
        String cypher = """
            MATCH (h1:Herb {name: $herbName})<-[:CONTAINS]-(f:Formula)-[:CONTAINS]->(h2:Herb)
            WHERE h1 <> h2
            RETURN h2.name as herb, count(f) as frequency
            ORDER BY frequency DESC LIMIT 20
            """;
        return neo4jTemplate.query(cypher, Map.of("herbName", herbName));
    }
}
```

**前端可视化（Vue3 + D3.js）**：

```vue
<template>
  <div class="knowledge-graph">
    <div class="search-panel">
      <v-text-field
        v-model="searchQuery"
        label="搜索药材、方剂、疾病"
        prepend-icon="mdi-magnify"
        @keyup.enter="searchKnowledge"
      />
    </div>
    <div id="graph-container" ref="graphContainer"></div>
    <div class="detail-panel" v-if="selectedNode">
      <knowledge-detail :node="selectedNode" />
    </div>
  </div>
</template>

<script setup>
import * as d3 from 'd3'
import { ref, onMounted } from 'vue'

const searchQuery = ref('')
const selectedNode = ref(null)
const graphContainer = ref(null)

const renderGraph = (data) => {
  const width = 800, height = 600
  
  const svg = d3.select(graphContainer.value)
    .append('svg')
    .attr('width', width)
    .attr('height', height)
  
  const simulation = d3.forceSimulation(data.nodes)
    .force('link', d3.forceLink(data.links).id(d => d.id))
    .force('charge', d3.forceManyBody().strength(-300))
    .force('center', d3.forceCenter(width / 2, height / 2))
  
  // 绘制连线
  const link = svg.append('g')
    .selectAll('line')
    .data(data.links)
    .enter().append('line')
    .attr('stroke', '#999')
    .attr('stroke-width', d => Math.sqrt(d.value))
  
  // 绘制节点
  const node = svg.append('g')
    .selectAll('circle')
    .data(data.nodes)
    .enter().append('circle')
    .attr('r', d => d.size)
    .attr('fill', d => d.color)
    .call(d3.drag()
      .on('start', dragstarted)
      .on('drag', dragged)
      .on('end', dragended))
    .on('click', (event, d) => {
      selectedNode.value = d
    })
  
  // 添加标签
  const label = svg.append('g')
    .selectAll('text')
    .data(data.nodes)
    .enter().append('text')
    .text(d => d.name)
    .attr('font-size', '12px')
    .attr('text-anchor', 'middle')
  
  simulation.on('tick', () => {
    link
      .attr('x1', d => d.source.x)
      .attr('y1', d => d.source.y)
      .attr('x2', d => d.target.x)
      .attr('y2', d => d.target.y)
    
    node
      .attr('cx', d => d.x)
      .attr('cy', d => d.y)
    
    label
      .attr('x', d => d.x)
      .attr('y', d => d.y + 5)
  })
}

const searchKnowledge = async () => {
  const response = await fetch(`/api/knowledge-graph/search?q=${searchQuery.value}`)
  const data = await response.json()
  renderGraph(data)
}
</script>
```

#### 2.1.3 数据库设计

**Neo4j图数据库结构**：

```cypher
// 创建节点约束和索引
CREATE CONSTRAINT herb_name_unique IF NOT EXISTS FOR (h:Herb) REQUIRE h.name IS UNIQUE;
CREATE CONSTRAINT formula_name_unique IF NOT EXISTS FOR (f:Formula) REQUIRE f.name IS UNIQUE;
CREATE CONSTRAINT disease_name_unique IF NOT EXISTS FOR (d:Disease) REQUIRE d.name IS UNIQUE;

CREATE INDEX herb_search_index IF NOT EXISTS FOR (h:Herb) ON (h.name, h.pinyin, h.alias);
CREATE INDEX formula_search_index IF NOT EXISTS FOR (f:Formula) ON (f.name, f.source);

// 示例数据导入
CREATE (川芎:Herb {
  name: '川芎',
  pinyin: 'chuanxiong',
  alias: '芎藭',
  nature: '辛，温',
  meridian: '肝、胆、心包经',
  effect: '活血行气，祛风止痛',
  usage: '3-10g',
  taboo: '阴虚火旺者慎用'
})

CREATE (血瘀头痛:Disease {
  name: '血瘀头痛',
  category: '头痛',
  symptoms: '头痛如刺，痛有定处，舌紫暗',
  pathogenesis: '血瘀阻络'
})

CREATE (血府逐瘀汤:Formula {
  name: '血府逐瘀汤',
  source: '医林改错',
  composition: '桃仁12g，红花9g，当归9g，生地黄9g，川芎4.5g，赤芍6g，牛膝9g，桔梗4.5g，柴胡3g，枳壳6g，甘草3g',
  function: '活血祛瘀，行气止痛',
  indication: '胸中血瘀，血行不畅'
})

// 创建关系
CREATE (川芎)-[:COMPOSES {dosage: '4.5g', role: '臣药'}]->(血府逐瘀汤)
CREATE (血府逐瘀汤)-[:TREATS]->(血瘀头痛)
CREATE (川芎)-[:TREATS]->(血瘀头痛)
```

### 模块二：方剂管理系统

#### 2.2.1 数据库设计

```sql
-- 方剂基本信息表
CREATE TABLE formula (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL COMMENT '方剂名称',
    alias VARCHAR(200) COMMENT '别名',
    source VARCHAR(100) COMMENT '出处典籍',
    dynasty VARCHAR(50) COMMENT '朝代',
    author VARCHAR(100) COMMENT '创方人',
    category_id INT COMMENT '分类ID',
    composition TEXT COMMENT '药物组成',
    preparation TEXT COMMENT '制法',
    usage TEXT COMMENT '用法',
    dosage_form VARCHAR(50) COMMENT '剂型',
    function_effect TEXT COMMENT '功用',
    main_treatment TEXT COMMENT '主治',
    clinical_application TEXT COMMENT '临床应用',
    pharmacological_action TEXT COMMENT '药理作用',
    contraindication TEXT COMMENT '禁忌',
    caution TEXT COMMENT '注意事项',
    modern_research TEXT COMMENT '现代研究',
    remarks TEXT COMMENT '备注',
    status TINYINT DEFAULT 1 COMMENT '状态 1-正常 0-禁用',
    created_by BIGINT COMMENT '创建人',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_name (name),
    INDEX idx_source (source),
    INDEX idx_category (category_id)
) COMMENT '方剂基本信息表';

-- 方剂分类表
CREATE TABLE formula_category (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL COMMENT '分类名称',
    parent_id INT DEFAULT 0 COMMENT '父级分类ID',
    sort_order INT DEFAULT 0 COMMENT '排序',
    description TEXT COMMENT '分类描述',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) COMMENT '方剂分类表';

-- 方剂药物组成表
CREATE TABLE formula_herb (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    formula_id BIGINT NOT NULL COMMENT '方剂ID',
    herb_id BIGINT NOT NULL COMMENT '药材ID',
    herb_name VARCHAR(50) NOT NULL COMMENT '药材名称',
    dosage VARCHAR(20) COMMENT '用量',
    unit VARCHAR(10) COMMENT '单位',
    role VARCHAR(20) COMMENT '配伍作用(君臣佐使)',
    processing VARCHAR(50) COMMENT '炮制方法',
    usage_note TEXT COMMENT '用法备注',
    sort_order INT DEFAULT 0 COMMENT '排序',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (formula_id) REFERENCES formula(id) ON DELETE CASCADE,
    INDEX idx_formula (formula_id),
    INDEX idx_herb (herb_id)
) COMMENT '方剂药物组成表';

-- 方剂主治疾病关联表
CREATE TABLE formula_disease (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    formula_id BIGINT NOT NULL COMMENT '方剂ID',
    disease_name VARCHAR(100) NOT NULL COMMENT '疾病名称',
    disease_code VARCHAR(50) COMMENT '疾病编码',
    syndrome VARCHAR(200) COMMENT '证候',
    efficacy_level TINYINT COMMENT '疗效等级 1-5',
    evidence_level VARCHAR(20) COMMENT '循证等级',
    clinical_data TEXT COMMENT '临床数据',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (formula_id) REFERENCES formula(id) ON DELETE CASCADE,
    INDEX idx_formula (formula_id),
    INDEX idx_disease (disease_name)
) COMMENT '方剂主治疾病关联表';

-- 方剂加减变化表
CREATE TABLE formula_modification (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    base_formula_id BIGINT NOT NULL COMMENT '基础方剂ID',
    modified_name VARCHAR(100) COMMENT '加减方名称',
    modification_type VARCHAR(20) COMMENT '变化类型(加味、减味、药量调整)',
    condition_description TEXT COMMENT '适应条件',
    herb_changes TEXT COMMENT '药物变化详情',
    effect_changes TEXT COMMENT '功效变化',
    created_by BIGINT COMMENT '创建人',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (base_formula_id) REFERENCES formula(id) ON DELETE CASCADE
) COMMENT '方剂加减变化表';

-- 方剂临床验案表
CREATE TABLE formula_case (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    formula_id BIGINT NOT NULL COMMENT '方剂ID',
    case_title VARCHAR(200) COMMENT '医案标题',
    patient_info TEXT COMMENT '患者信息',
    chief_complaint TEXT COMMENT '主诉',
    history_present TEXT COMMENT '现病史',
    physical_exam TEXT COMMENT '体格检查',
    tongue_pulse TEXT COMMENT '舌脉',
    tcm_diagnosis TEXT COMMENT '中医诊断',
    treatment_principle TEXT COMMENT '治法',
    prescription TEXT COMMENT '处方',
    follow_up TEXT COMMENT '随访记录',
    outcome TEXT COMMENT '疗效',
    doctor_name VARCHAR(50) COMMENT '医生姓名',
    hospital VARCHAR(100) COMMENT '医院',
    case_date DATE COMMENT '医案日期',
    source VARCHAR(100) COMMENT '资料来源',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (formula_id) REFERENCES formula(id) ON DELETE CASCADE
) COMMENT '方剂临床验案表';

-- 方剂评价表
CREATE TABLE formula_evaluation (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    formula_id BIGINT NOT NULL COMMENT '方剂ID',
    evaluator_id BIGINT COMMENT '评价人ID',
    evaluation_type VARCHAR(20) COMMENT '评价类型(临床疗效、安全性、经济性)',
    score DECIMAL(3,1) COMMENT '评分',
    evaluation_content TEXT COMMENT '评价内容',
    evidence_files TEXT COMMENT '证据文件',
    evaluation_date DATE COMMENT '评价日期',
    status VARCHAR(20) DEFAULT 'pending' COMMENT '状态',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (formula_id) REFERENCES formula(id) ON DELETE CASCADE
) COMMENT '方剂评价表';
```

#### 2.2.2 后端API设计

```java
@RestController
@RequestMapping("/formula")
public class FormulaController {
    
    @Autowired
    private FormulaService formulaService;
    
    // 方剂分页查询
    @GetMapping("/page")
    public Result<Page<FormulaVO>> getFormulaPage(
            @RequestParam(defaultValue = "1") Integer page,
            @RequestParam(defaultValue = "10") Integer size,
            @RequestParam(required = false) String keyword,
            @RequestParam(required = false) Integer categoryId,
            @RequestParam(required = false) String source) {
        
        FormulaQueryDTO query = new FormulaQueryDTO();
        query.setKeyword(keyword);
        query.setCategoryId(categoryId);
        query.setSource(source);
        
        Page<FormulaVO> result = formulaService.getFormulaPage(page, size, query);
        return Result.success(result);
    }
    
    // 方剂详情
    @GetMapping("/{id}")
    public Result<FormulaDetailVO> getFormulaDetail(@PathVariable Long id) {
        FormulaDetailVO detail = formulaService.getFormulaDetail(id);
        return Result.success(detail);
    }
    
    // 根据症状推荐方剂
    @PostMapping("/recommend")
    public Result<List<FormulaRecommendVO>> recommendFormula(
            @RequestBody SymptomAnalysisDTO symptoms) {
        List<FormulaRecommendVO> recommendations = formulaService.recommendBySymptoms(symptoms);
        return Result.success(recommendations);
    }
    
    // 组方规律分析
    @GetMapping("/analysis/herb-combinations")
    public Result<List<HerbCombinationVO>> analyzeHerbCombinations(
            @RequestParam String herbName) {
        List<HerbCombinationVO> combinations = formulaService.analyzeHerbCombinations(herbName);
        return Result.success(combinations);
    }
    
    // 方剂对比分析
    @PostMapping("/compare")
    public Result<FormulaComparisonVO> compareFormulas(
            @RequestBody List<Long> formulaIds) {
        FormulaComparisonVO comparison = formulaService.compareFormulas(formulaIds);
        return Result.success(comparison);
    }
}

@Service
public class FormulaService {
    
    @Autowired
    private FormulaMapper formulaMapper;
    
    @Autowired
    private KnowledgeGraphService knowledgeGraphService;
    
    // 智能推荐算法
    public List<FormulaRecommendVO> recommendBySymptoms(SymptomAnalysisDTO symptoms) {
        // 1. 症状向量化
        List<String> symptomList = symptoms.getSymptoms();
        
        // 2. 相似度计算
        List<Formula> candidateFormulas = formulaMapper.findBySymptoms(symptomList);
        
        // 3. 评分排序
        return candidateFormulas.stream()
                .map(this::calculateRecommendScore)
                .sorted((a, b) -> Double.compare(b.getScore(), a.getScore()))
                .limit(10)
                .collect(Collectors.toList());
    }
    
    private FormulaRecommendVO calculateRecommendScore(Formula formula) {
        // 实现推荐评分算法
        // 考虑因素：症状匹配度、使用频次、疗效评价、安全性等
        double score = 0.0;
        
        // 症状匹配度 (40%)
        score += calculateSymptomMatch(formula) * 0.4;
        
        // 临床使用频次 (25%)
        score += calculateUsageFrequency(formula) * 0.25;
        
        // 疗效评价 (25%)
        score += calculateEfficacyScore(formula) * 0.25;
        
        // 安全性评级 (10%)
        score += calculateSafetyScore(formula) * 0.1;
        
        return FormulaRecommendVO.builder()
                .formulaId(formula.getId())
                .formulaName(formula.getName())
                .score(score)
                .matchedSymptoms(getMatchedSymptoms(formula))
                .recommendation(generateRecommendation(formula, score))
                .build();
    }
}
```

#### 2.2.3 前端界面设计

```vue
<template>
  <div class="formula-management">
    <!-- 搜索筛选区 -->
    <v-card class="search-panel mb-4">
      <v-card-text>
        <v-row>
          <v-col cols="4">
            <v-text-field
              v-model="searchForm.keyword"
              label="搜索方剂名称、出处、功效"
              prepend-icon="mdi-magnify"
              clearable
            />
          </v-col>
          <v-col cols="3">
            <v-select
              v-model="searchForm.categoryId"
              :items="categories"
              item-title="name"
              item-value="id"
              label="方剂分类"
              clearable
            />
          </v-col>
          <v-col cols="3">
            <v-select
              v-model="searchForm.source"
              :items="sources"
              label="出处典籍"
              clearable
            />
          </v-col>
          <v-col cols="2">
            <v-btn color="primary" @click="searchFormulas" block>
              <v-icon left>mdi-magnify</v-icon>
              搜索
            </v-btn>
          </v-col>
        </v-row>
      </v-card-text>
    </v-card>

    <!-- 症状推荐区 -->
    <v-card class="recommendation-panel mb-4">
      <v-card-title>智能方剂推荐</v-card-title>
      <v-card-text>
        <v-row>
          <v-col cols="8">
            <v-combobox
              v-model="selectedSymptoms"
              :items="symptomOptions"
              label="输入患者症状"
              multiple
              chips
              clearable
              hint="支持多个症状组合分析"
            />
          </v-col>
          <v-col cols="4">
            <v-btn color="success" @click="getRecommendations" block>
              <v-icon left>mdi-lightbulb</v-icon>
              智能推荐
            </v-btn>
          </v-col>
        </v-row>
        
        <!-- 推荐结果 -->
        <div v-if="recommendations.length > 0" class="mt-4">
          <h4>推荐方剂：</h4>
          <v-chip-group column>
            <v-chip
              v-for="rec in recommendations"
              :key="rec.formulaId"
              :color="getScoreColor(rec.score)"
              @click="viewFormulaDetail(rec.formulaId)"
            >
              {{ rec.formulaName }} ({{ (rec.score * 100).toFixed(1) }}%)
            </v-chip>
          </v-chip-group>
        </div>
      </v-card-text>
    </v-card>

    <!-- 方剂列表 -->
    <v-card>
      <v-card-title>
        方剂库
        <v-spacer></v-spacer>
        <v-btn color="primary" @click="showAddDialog">
          <v-icon left>mdi-plus</v-icon>
          添加方剂
        </v-btn>
      </v-card-title>
      
      <v-data-table
        :headers="headers"
        :items="formulas"
        :loading="loading"
        :server-items-length="total"
        @update:options="handleOptionsUpdate"
      >
        <template v-slot:item.composition="{ item }">
          <v-tooltip bottom>
            <template v-slot:activator="{ props }">
              <span v-bind="props" class="text-truncate" style="max-width: 200px;">
                {{ item.composition }}
              </span>
            </template>
            <span>{{ item.composition }}</span>
          </v-tooltip>
        </template>
        
        <template v-slot:item.actions="{ item }">
          <v-btn icon size="small" @click="viewDetail(item)">
            <v-icon>mdi-eye</v-icon>
          </v-btn>
          <v-btn icon size="small" @click="editFormula(item)">
            <v-icon>mdi-pencil</v-icon>
          </v-btn>
          <v-btn icon size="small" @click="analyzeFormula(item)">
            <v-icon>mdi-chart-line</v-icon>
          </v-btn>
        </template>
      </v-data-table>
    </v-card>

    <!-- 方剂详情对话框 -->
    <formula-detail-dialog
      v-model="detailDialog"
      :formula="selectedFormula"
    />

    <!-- 方剂分析对话框 -->
    <formula-analysis-dialog
      v-model="analysisDialog"
      :formula="selectedFormula"
    />
  </div>
</template>

<script setup>
import { ref, reactive, onMounted } from 'vue'
import { useApi } from '@/composables/useApi'

const { request } = useApi()

// 响应式数据
const loading = ref(false)
const formulas = ref([])
const total = ref(0)
const recommendations = ref([])
const selectedSymptoms = ref([])
const detailDialog = ref(false)
const analysisDialog = ref(false)
const selectedFormula = ref(null)

const searchForm = reactive({
  keyword: '',
  categoryId: null,
  source: ''
})

const headers = [
  { title: '方剂名称', key: 'name', width: '15%' },
  { title: '出处', key: 'source', width: '12%' },
  { title: '药物组成', key: 'composition', width: '25%' },
  { title: '功用', key: 'function', width: '20%' },
  { title: '主治', key: 'mainTreatment', width: '20%' },
  { title: '操作', key: 'actions', width: '8%', sortable: false }
]

// 获取智能推荐
const getRecommendations = async () => {
  if (selectedSymptoms.value.length === 0) return
  
  try {
    const response = await request.post('/api/formula/recommend', {
      symptoms: selectedSymptoms.value
    })
    recommendations.value = response.data
  } catch (error) {
    console.error('获取推荐失败:', error)
  }
}

// 根据评分获取颜色
const getScoreColor = (score) => {
  if (score >= 0.8) return 'green'
  if (score >= 0.6) return 'orange'
  return 'grey'
}

// 方剂分析
const analyzeFormula = (formula) => {
  selectedFormula.value = formula
  analysisDialog.value = true
}
</script>
```

### 模块三：AI科研助手系统

#### 2.3.1 功能设计

- **智能问答**：基于中医药知识的专业问答
- **文献检索**：智能文献推荐和摘要生成
- **研究方案生成**：根据研究主题生成开题报告大纲
- **数据分析辅助**：协助科研数据分析和可视化

#### 2.3.2 实现方案

**后端AI服务**：

```java
@Service
public class AIResearchService {
    
    @Value("${ai.model.api-key}")
    private String apiKey;
    
    @Autowired
    private VectorSearchService vectorSearchService;
    
    @Autowired
    private LiteratureService literatureService;
    
    // 生成研究方案
    public ResearchProposalVO generateResearchProposal(String topic) {
        // 1. 检索相关文献
        List<Literature> relatedPapers = literatureService.searchByTopic(topic);
        
        // 2. 构建提示词
        String prompt = buildResearchPrompt(topic, relatedPapers);
        
        // 3. 调用大语言模型
        String proposal = callLLMAPI(prompt);
        
        // 4. 解析和结构化输出
        return parseProposal(proposal, topic);
    }
    
    private String buildResearchPrompt(String topic, List<Literature> papers) {
        StringBuilder prompt = new StringBuilder();
        prompt.append("你是一位中医药研究专家，请根据以下研究主题和相关文献，生成一份详细的开题报告大纲：\n\n");
        prompt.append("研究主题：").append(topic).append("\n\n");
        prompt.append("相关文献：\n");
        
        papers.stream().limit(5).forEach(paper -> {
            prompt.append("- ").append(paper.getTitle())
                  .append("（").append(paper.getAuthors()).append("，")
                  .append(paper.getYear()).append("）\n");
        });
        
        prompt.append("\n请按以下格式生成开题报告大纲：\n");
        prompt.append("1. 研究背景与意义\n");
        prompt.append("2. 国内外研究现状\n");
        prompt.append("3. 研究目标与内容\n");
        prompt.append("4. 研究方法与技术路线\n");
        prompt.append("5. 预期成果与创新点\n");
        prompt.append("6. 进度安排\n");
        prompt.append("请确保内容专业、具体，符合中医药研究特点。");
        
        return prompt.toString();
    }
    
    // 智能问答
    public String intelligentQA(String question, String context) {
        // 1. 向量搜索相关知识
        List<String> relatedKnowledge = vectorSearchService.searchSimilar(question);
        
        // 2. 构建增强提示词
        String enhancedPrompt = String.format("""
            你是一位专业的中医药专家，请基于以下知识库内容回答用户问题：
            
            知识库内容：
            %s
            
            用户问题：%s
            
            请提供准确、专业的回答，并注明知识来源。
            """, String.join("\n", relatedKnowledge), question);
        
        return callLLMAPI(enhancedPrompt);
    }
    
    private String callLLMAPI(String prompt) {
        // 调用OpenAI或其他大语言模型API
        // 这里使用RestTemplate或HttpClient实现
        RestTemplate restTemplate = new RestTemplate();
        
        HttpHeaders headers = new HttpHeaders();
        headers.setContentType(MediaType.APPLICATION_JSON);
        headers.setBearerAuth(apiKey);
        
        Map<String, Object> requestBody = Map.of(
            "model", "gpt-3.5-turbo",
            "messages", List.of(
                Map.of("role", "user", "content", prompt)
            ),
            "max_tokens", 2000,
            "temperature", 0.7
        );
        
        HttpEntity<Map<String, Object>> entity = new HttpEntity<>(requestBody, headers);
        
        try {
            ResponseEntity<Map> response = restTemplate.postForEntity(
                "https://api.openai.com/v1/chat/completions", 
                entity, 
                Map.class
            );
            
            Map<String, Object> responseBody = response.getBody();
            List<Map<String, Object>> choices = (List<Map<String, Object>>) responseBody.get("choices");
            Map<String, Object> message = (Map<String, Object>) choices.get(0).get("message");
            
            return (String) message.get("content");
        } catch (Exception e) {
            log.error("调用AI API失败", e);
            return "抱歉，AI服务暂时不可用，请稍后重试。";
        }
    }
}

// 向量搜索服务
@Service
public class VectorSearchService {
    
    @Autowired
    private RedisTemplate<String, Object> redisTemplate;
    
    // 文本向量化
    public float[] vectorizeText(String text) {
        // 调用embedding API或使用本地模型
        // 返回文本的向量表示
        return callEmbeddingAPI(text);
    }
    
    // 相似度搜索
    public List<String> searchSimilar(String query, int topK) {
        float[] queryVector = vectorizeText(query);
        
        // 从向量数据库中搜索最相似的内容
        // 这里可以使用Redis Vector Search或专门的向量数据库
        List<String> results = new ArrayList<>();
        
        // 实现向量相似度搜索逻辑
        // ...
        
        return results;
    }
}
```

**前端AI助手界面**：

```vue
<template>
  <div class="ai-research-assistant">
    <v-container>
      <v-row>
        <!-- 对话区域 -->
        <v-col cols="8">
          <v-card height="600" class="chat-container">
            <v-card-title>AI科研助手</v-card-title>
            <v-divider></v-divider>
            
            <div class="chat-messages" ref="messagesContainer">
              <div
                v-for="(message, index) in messages"
                :key="index"
                :class="['message', message.isUser ? 'user-message' : 'ai-message']"
              >
                <div class="message-content">
                  <div class="message-text" v-html="formatMessage(message.text)"></div>
                  <div class="message-time">{{ formatTime(message.timestamp) }}</div>
                </div>
              </div>
            </div>
            
            <v-divider></v-divider>
            <div class="chat-input">
              <v-text-field
                v-model="inputMessage"
                label="输入您的问题..."
                @keyup.enter="sendMessage"
                :loading="isTyping"
                append-inner-icon="mdi-send"
                @click:append-inner="sendMessage"
              />
            </div>
          </v-card>
        </v-col>
        
        <!-- 功能面板 -->
        <v-col cols="4">
          <v-card class="mb-4">
            <v-card-title>快捷功能</v-card-title>
            <v-card-text>
              <v-btn block class="mb-2" @click="generateProposal">
                <v-icon left>mdi-file-document</v-icon>
                生成开题报告
              </v-btn>
              <v-btn block class="mb-2" @click="searchLiterature">
                <v-icon left>mdi-book-search</v-icon>
                文献检索
              </v-btn>
              <v-btn block class="mb-2" @click="analyzeData">
                <v-icon left>mdi-chart-bar</v-icon>
                数据分析
              </v-btn>
            </v-card-text>
          </v-card>
          
          <v-card>
            <v-card-title>常见问题</v-card-title>
            <v-card-text>
              <v-chip
                v-for="question in commonQuestions"
                :key="question"
                class="ma-1"
                small
                @click="askQuestion(question)"
              >
                {{ question }}
              </v-chip>
            </v-card-text>
          </v-card>
        </v-col>
      </v-row>
    </v-container>
    
    <!-- 开题报告生成对话框 -->
    <research-proposal-dialog
      v-model="proposalDialog"
      @generate="handleProposalGenerate"
    />
  </div>
</template>

<script setup>
import { ref, reactive, nextTick, onMounted } from 'vue'
import { useApi } from '@/composables/useApi'
import { marked } from 'marked'

const { request } = useApi()

const messages = ref([])
const inputMessage = ref('')
const isTyping = ref(false)
const messagesContainer = ref(null)
const proposalDialog = ref(false)

const commonQuestions = [
  '川芎的功效与作用',
  '血府逐瘀汤的组成',
  '如何设计中医药临床试验',
  '中药质量控制标准',
  '方剂配伍规律分析方法'
]

// 发送消息
const sendMessage = async () => {
  if (!inputMessage.value.trim()) return
  
  const userMessage = {
    text: inputMessage.value,
    isUser: true,
    timestamp: new Date()
  }
  
  messages.value.push(userMessage)
  const question = inputMessage.value
  inputMessage.value = ''
  isTyping.value = true
  
  try {
    const response = await request.post('/api/ai/qa', {
      question: question,
      context: getConversationContext()
    })
    
    const aiMessage = {
      text: response.data.answer,
      isUser: false,
      timestamp: new Date(),
      sources: response.data.sources
    }
    
    messages.value.push(aiMessage)
  } catch (error) {
    console.error('AI回答失败:', error)
    messages.value.push({
      text: '抱歉，AI助手暂时不可用，请稍后重试。',
      isUser: false,
      timestamp: new Date()
    })
  } finally {
    isTyping.value = false
    scrollToBottom()
  }
}

// 生成开题报告
const generateProposal = () => {
  proposalDialog.value = true
}

const handleProposalGenerate = async (topic) => {
  const userMessage = {
    text: `请帮我生成关于"${topic}"的开题报告大纲`,
    isUser: true,
    timestamp: new Date()
  }
  
  messages.value.push(userMessage)
  isTyping.value = true
  
  try {
    const response = await request.post('/api/ai/research-proposal', {
      topic: topic
    })
    
    const aiMessage = {
      text: response.data.proposal,
      isUser: false,
      timestamp: new Date(),
      type: 'proposal'
    }
    
    messages.value.push(aiMessage)
  } catch (error) {
    console.error('生成开题报告失败:', error)
  } finally {
    isTyping.value = false
    scrollToBottom()
  }
}

// 格式化消息（支持Markdown）
const formatMessage = (text) => {
  return marked(text)
}

// 滚动到底部
const scrollToBottom = () => {
  nextTick(() => {
    if (messagesContainer.value) {
      messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight
    }
  })
}

onMounted(() => {
  // 初始欢迎消息
  messages.value.push({
    text: '您好！我是AI科研助手，可以帮助您进行中医药研究。您可以询问我关于中医药的专业问题，或使用右侧的快捷功能。',
    isUser: false,
    timestamp: new Date()
  })
})
</script>

<style scoped>
.chat-container {
  display: flex;
  flex-direction: column;
}

.chat-messages {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
  max-height: 500px;
}

.message {
  margin-bottom: 16px;
  display: flex;
}

.user-message {
  justify-content: flex-end;
}

.ai-message {
  justify-content: flex-start;
}

.message-content {
  max-width: 70%;
  padding: 12px 16px;
  border-radius: 18px;
  position: relative;
}

.user-message .message-content {
  background-color: #1976d2;
  color: white;
}

.ai-message .message-content {
  background-color: #f5f5f5;
  color: #333;
}

.message-time {
  font-size: 12px;
  opacity: 0.7;
  margin-top: 4px;
  text-align: right;
}

.chat-input {
  padding: 16px;
}
</style>
```

### 模块四：科研教育一体化平台

#### 2.4.1 教学资源管理

**数据库设计**：

```sql
-- 课程分类表
CREATE TABLE course_category (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL COMMENT '分类名称',
    parent_id INT DEFAULT 0 COMMENT '父级分类',
    icon VARCHAR(100) COMMENT '图标',
    sort_order INT DEFAULT 0 COMMENT '排序',
    description TEXT COMMENT '描述',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) COMMENT '课程分类表';

-- 课程表
CREATE TABLE course (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    title VARCHAR(200) NOT NULL COMMENT '课程标题',
    subtitle VARCHAR(500) COMMENT '课程副标题',
    category_id INT NOT NULL COMMENT '分类ID',
    teacher_id BIGINT NOT NULL COMMENT '教师ID',
    cover_image VARCHAR(255) COMMENT '封面图片',
    introduction TEXT COMMENT '课程介绍',
    objectives TEXT COMMENT '学习目标',
    prerequisites TEXT COMMENT '先修要求',
    difficulty_level TINYINT DEFAULT 1 COMMENT '难度等级 1-5',
    duration INT COMMENT '课程时长(分钟)',
    price DECIMAL(10,2) DEFAULT 0 COMMENT '课程价格',
    status VARCHAR(20) DEFAULT 'draft' COMMENT '状态',
    view_count INT DEFAULT 0 COMMENT '观看次数',
    student_count INT DEFAULT 0 COMMENT '学生数量',
    rating DECIMAL(3,1) DEFAULT 0 COMMENT '评分',
    tags VARCHAR(500) COMMENT '标签',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (category_id) REFERENCES course_category(id),
    INDEX idx_category (category_id),
    INDEX idx_teacher (teacher_id),
    INDEX idx_status (status)
) COMMENT '课程表';

-- 章节表
CREATE TABLE course_chapter (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    course_id BIGINT NOT NULL COMMENT '课程ID',
    title VARCHAR(200) NOT NULL COMMENT '章节标题',
    description TEXT COMMENT '章节描述',
    sort_order INT DEFAULT 0 COMMENT '排序',
    duration INT DEFAULT 0 COMMENT '时长',
    status VARCHAR(20) DEFAULT 'published' COMMENT '状态',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (course_id) REFERENCES course(id) ON DELETE CASCADE,
    INDEX idx_course (course_id)
) COMMENT '课程章节表';

-- 课时表
CREATE TABLE course_lesson (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    chapter_id BIGINT NOT NULL COMMENT '章节ID',
    course_id BIGINT NOT NULL COMMENT '课程ID',
    title VARCHAR(200) NOT NULL COMMENT '课时标题',
    content_type VARCHAR(20) NOT NULL COMMENT '内容类型(video/document/quiz)',
    content_url VARCHAR(500) COMMENT '内容地址',
    content TEXT COMMENT '文本内容',
    duration INT DEFAULT 0 COMMENT '时长(秒)',
    sort_order INT DEFAULT 0 COMMENT '排序',
    is_free BOOLEAN DEFAULT FALSE COMMENT '是否免费',
    download_allowed BOOLEAN DEFAULT FALSE COMMENT '是否允许下载',
    status VARCHAR(20) DEFAULT 'published' COMMENT '状态',
    view_count INT DEFAULT 0 COMMENT '观看次数',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (chapter_id) REFERENCES course_chapter(id) ON DELETE CASCADE,
    FOREIGN KEY (course_id) REFERENCES course(id) ON DELETE CASCADE,
    INDEX idx_chapter (chapter_id),
    INDEX idx_course (course_id)
) COMMENT '课程课时表';

-- 学习记录表
CREATE TABLE study_record (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '用户ID',
    course_id BIGINT NOT NULL COMMENT '课程ID',
    lesson_id BIGINT NOT NULL COMMENT '课时ID',
    progress DECIMAL(5,2) DEFAULT 0 COMMENT '学习进度百分比',
    study_duration INT DEFAULT 0 COMMENT '学习时长(秒)',
    completed_at TIMESTAMP NULL COMMENT '完成时间',
    last_position INT DEFAULT 0 COMMENT '最后观看位置(秒)',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (course_id) REFERENCES course(id) ON DELETE CASCADE,
    FOREIGN KEY (lesson_id) REFERENCES course_lesson(id) ON DELETE CASCADE,
    UNIQUE KEY uk_user_lesson (user_id, lesson_id),
    INDEX idx_user_course (user_id, course_id)
) COMMENT '学习记录表';

-- 科研项目表
CREATE TABLE research_project (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    project_name VARCHAR(200) NOT NULL COMMENT '项目名称',
    project_code VARCHAR(50) COMMENT '项目编号',
    project_type VARCHAR(50) COMMENT '项目类型',
    funding_source VARCHAR(100) COMMENT '资助来源',
    funding_amount DECIMAL(12,2) COMMENT '资助金额',
    principal_investigator BIGINT COMMENT '项目负责人ID',
    start_date DATE COMMENT '开始日期',
    end_date DATE COMMENT '结束日期',
    status VARCHAR(20) DEFAULT 'active' COMMENT '状态',
    abstract TEXT COMMENT '项目摘要',
    keywords VARCHAR(500) COMMENT '关键词',
    research_field VARCHAR(100) COMMENT '研究领域',
    achievements TEXT COMMENT '项目成果',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX idx_pi (principal_investigator),
    INDEX idx_status (status),
    INDEX idx_type (project_type)
) COMMENT '科研项目表';

-- 科研成果表
CREATE TABLE research_achievement (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    project_id BIGINT COMMENT '关联项目ID',
    achievement_type VARCHAR(50) NOT NULL COMMENT '成果类型(paper/patent/award/book)',
    title VARCHAR(500) NOT NULL COMMENT '成果标题',
    authors TEXT COMMENT '作者',
    publication VARCHAR(200) COMMENT '发表期刊/出版社',
    publish_date DATE COMMENT '发表日期',
    impact_factor DECIMAL(6,3) COMMENT '影响因子',
    citation_count INT DEFAULT 0 COMMENT '引用次数',
    doi VARCHAR(100) COMMENT 'DOI',
    abstract TEXT COMMENT '摘要',
    keywords VARCHAR(500) COMMENT '关键词',
    file_url VARCHAR(500) COMMENT '文件地址',
    status VARCHAR(20) DEFAULT 'published' COMMENT '状态',
    created_by BIGINT COMMENT '创建人',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (project_id) REFERENCES research_project(id),
    INDEX idx_project (project_id),
    INDEX idx_type (achievement_type),
    INDEX idx_author (created_by)
) COMMENT '科研成果表';
```

#### 2.4.2 在线学习系统实现

```java
@RestController
@RequestMapping("/api/learning")
public class LearningController {
    
    @Autowired
    private CourseService courseService;
    
    @Autowired
    private StudyRecordService studyRecordService;
    
    // 获取课程列表
    @GetMapping("/courses")
    public Result<Page<CourseVO>> getCourses(
            @RequestParam(defaultValue = "1") Integer page,
            @RequestParam(defaultValue = "12") Integer size,
            @RequestParam(required = false) Integer categoryId,
            @RequestParam(required = false) String keyword,
            @RequestParam(required = false) String level) {
        
        CourseQueryDTO query = CourseQueryDTO.builder()
                .categoryId(categoryId)
                .keyword(keyword)
                .level(level)
                .build();
        
        Page<CourseVO> courses = courseService.getCourses(page, size, query);
        return Result.success(courses);
    }
    
    // 获取课程详情
    @GetMapping("/courses/{courseId}")
    public Result<CourseDetailVO> getCourseDetail(
            @PathVariable Long courseId,
            @RequestHeader("Authorization") String token) {
        
        Long userId = JwtUtils.getUserId(token);
        CourseDetailVO detail = courseService.getCourseDetail(courseId, userId);
        return Result.success(detail);
    }
    
    // 开始学习
    @PostMapping("/study/{lessonId}")
    public Result<Void> startStudy(@PathVariable Long lessonId,
                                   @RequestHeader("Authorization") String token) {
        Long userId = JwtUtils.getUserId(token);
        studyRecordService.startStudy(userId, lessonId);
        return Result.success();
    }
    
    // 更新学习进度
    @PutMapping("/progress")
    public Result<Void> updateProgress(@RequestBody StudyProgressDTO progressDTO,
                                       @RequestHeader("Authorization") String token) {
        Long userId = JwtUtils.getUserId(token);
        progressDTO.setUserId(userId);
        studyRecordService.updateProgress(progressDTO);
        return Result.success();
    }
    
    // 获取学习统计
    @GetMapping("/statistics")
    public Result<StudyStatisticsVO> getStudyStatistics(
            @RequestHeader("Authorization") String token) {
        Long userId = JwtUtils.getUserId(token);
        StudyStatisticsVO statistics = studyRecordService.getStudyStatistics(userId);
        return Result.success(statistics);
    }
}

@Service
public class StudyRecordService {
    
    @Autowired
    private StudyRecordMapper studyRecordMapper;
    
    // 更新学习进度
    @Transactional
    public void updateProgress(StudyProgressDTO progressDTO) {
        StudyRecord record = studyRecordMapper.findByUserAndLesson(
                progressDTO.getUserId(), progressDTO.getLessonId());
        
        if (record == null) {
            record = new StudyRecord();
            record.setUserId(progressDTO.getUserId());
            record.setLessonId(progressDTO.getLessonId());
            record.setCourseId(progressDTO.getCourseId());
        }
        
        record.setProgress(progressDTO.getProgress());
        record.setStudyDuration(record.getStudyDuration() + progressDTO.getDuration());
        record.setLastPosition(progressDTO.getPosition());
        
        if (progressDTO.getProgress() >= 100) {
            record.setCompletedAt(new Date());
        }
        
        if (record.getId() == null) {
            studyRecordMapper.insert(record);
        } else {
            studyRecordMapper.updateById(record);
        }
        
        // 更新课程整体进度
        updateCourseProgress(progressDTO.getUserId(), progressDTO.getCourseId());
    }
    
    // 计算课程整体进度
    private void updateCourseProgress(Long userId, Long courseId) {
        List<StudyRecord> records = studyRecordMapper.findByCourseAndUser(courseId, userId);
        
        if (records.isEmpty()) return;
        
        double totalProgress = records.stream()
                .mapToDouble(StudyRecord::getProgress)
                .average()
                .orElse(0.0);
        
        // 更新课程进度记录
        CourseProgress courseProgress = courseProgressMapper.findByUserAndCourse(userId, courseId);
        if (courseProgress == null) {
            courseProgress = new CourseProgress();
            courseProgress.setUserId(userId);
            courseProgress.setCourseId(courseId);
        }
        
        courseProgress.setProgress((int) totalProgress);
        if (totalProgress >= 100) {
            courseProgress.setCompletedAt(new Date());
        }
        
        courseProgressMapper.insertOrUpdate(courseProgress);
    }
    
    // 生成学习统计
    public StudyStatisticsVO getStudyStatistics(Long userId) {
        StudyStatisticsVO statistics = new StudyStatisticsVO();
        
        // 学习时长统计
        Integer totalDuration = studyRecordMapper.getTotalStudyDuration(userId);
        statistics.setTotalStudyTime(totalDuration != null ? totalDuration : 0);
        
        // 课程完成情况
        List<CourseProgress> completedCourses = courseProgressMapper.getCompletedCourses(userId);
        statistics.setCompletedCourses(completedCourses.size());
        
        // 本周学习时长
        Integer weeklyDuration = studyRecordMapper.getWeeklyStudyDuration(userId);
        statistics.setWeeklyStudyTime(weeklyDuration != null ? weeklyDuration : 0);
        
        // 学习排名
        Integer ranking = studyRecordMapper.getUserStudyRanking(userId);
        statistics.setStudyRanking(ranking);
        
        // 最近学习记录
        List<StudyRecord> recentRecords = studyRecordMapper.getRecentStudyRecords(userId, 10);
        statistics.setRecentLessons(recentRecords.stream()
                .map(this::convertToRecentLessonVO)
                .collect(Collectors.toList()));
        
        return statistics;
    }
}
```

#### 2.4.3 视频播放器组件

```vue
<template>
  <div class="video-player-container">
    <div class="video-player" ref="videoPlayer">
      <video
        ref="videoElement"
        :src="videoUrl"
        @loadedmetadata="onVideoLoaded"
        @timeupdate="onTimeUpdate"
        @ended="onVideoEnded"
        @pause="onVideoPause"
        @play="onVideoPlay"
        preload="metadata"
        playsinline
      ></video>
      
      <!-- 自定义控制条 -->
      <div class="video-controls" v-show="showControls">
        <div class="progress-container">
          <div class="progress-bar" @click="seek">
            <div class="progress-buffer" :style="{ width: bufferProgress + '%' }"></div>
            <div class="progress-played" :style="{ width: playProgress + '%' }"></div>
            <div class="progress-thumb" :style="{ left: playProgress + '%' }"></div>
          </div>
        </div>
        
        <div class="control-buttons">
          <v-btn icon @click="togglePlay">
            <v-icon>{{ isPlaying ? 'mdi-pause' : 'mdi-play' }}</v-icon>
          </v-btn>
          
          <span class="time-display">
            {{ formatTime(currentTime) }} / {{ formatTime(duration) }}
          </span>
          
          <v-spacer></v-spacer>
          
          <v-btn icon @click="toggleMute">
            <v-icon>{{ isMuted ? 'mdi-volume-off' : 'mdi-volume-high' }}</v-icon>
          </v-btn>
          
          <v-btn icon @click="changePlaybackRate">
            <span class="playback-rate">{{ playbackRate }}x</span>
          </v-btn>
          
          <v-btn icon @click="toggleFullscreen">
            <v-icon>mdi-fullscreen</v-icon>
          </v-btn>
        </div>
      </div>
      
      <!-- 课程笔记侧边栏 -->
      <div v-if="showNotes" class="notes-sidebar">
        <div class="notes-header">
          <h4>课程笔记</h4>
          <v-btn icon small @click="showNotes = false">
            <v-icon>mdi-close</v-icon>
          </v-btn>
        </div>
        
        <div class="notes-content">
          <div v-for="note in notes" :key="note.id" class="note-item">
            <div class="note-time" @click="seekToNote(note.timestamp)">
              {{ formatTime(note.timestamp) }}
            </div>
            <div class="note-text">{{ note.content }}</div>
          </div>
        </div>
        
        <div class="add-note">
          <v-textarea
            v-model="newNote"
            label="添加笔记"
            rows="3"
            @keyup.ctrl.enter="addNote"
          ></v-textarea>
          <v-btn color="primary" small @click="addNote">
            添加笔记
          </v-btn>
        </div>
      </div>
    </div>
    
    <!-- 播放控制提示 -->
    <div v-if="showPlayHint" class="play-hint">
      <v-icon large>mdi-play-circle</v-icon>
      <p>点击播放视频</p>
    </div>
  </div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, watch } from 'vue'
import { useApi } from '@/composables/useApi'

const props = defineProps({
  lessonId: {
    type: Number,
    required: true
  },
  videoUrl: {
    type: String,
    required: true
  },
  autoPlay: {
    type: Boolean,
    default: false
  }
})

const emit = defineEmits(['progress-update', 'video-completed'])

const { request } = useApi()

// 视频相关状态
const videoElement = ref(null)
const videoPlayer = ref(null)
const isPlaying = ref(false)
const currentTime = ref(0)
const duration = ref(0)
const playProgress = ref(0)
const bufferProgress = ref(0)
const isMuted = ref(false)
const playbackRate = ref(1)
const showControls = ref(true)
const showPlayHint = ref(true)

// 笔记相关状态
const showNotes = ref(false)
const notes = ref([])
const newNote = ref('')

// 学习进度跟踪
const progressUpdateInterval = ref(null)
const lastProgressTime = ref(0)

// 视频事件处理
const onVideoLoaded = () => {
  duration.value = videoElement.value.duration
  showPlayHint.value = false
  
  if (props.autoPlay) {
    playVideo()
  }
}

const onTimeUpdate = () => {
  currentTime.value = videoElement.value.currentTime
  playProgress.value = (currentTime.value / duration.value) * 100
  
  // 每5秒更新一次学习进度
  if (currentTime.value - lastProgressTime.value >= 5) {
    updateProgress()
    lastProgressTime.value = currentTime.value
  }
}

const onVideoEnded = () => {
  isPlaying.value = false
  updateProgress()
  emit('video-completed', {
    lessonId: props.lessonId,
    duration: duration.value
  })
}

const onVideoPlay = () => {
  isPlaying.value = true
  startProgressTracking()
}

const onVideoPause = () => {
  isPlaying.value = false
  updateProgress()
}

// 播放控制
const togglePlay = () => {
  if (isPlaying.value) {
    videoElement.value.pause()
  } else {
    playVideo()
  }
}

const playVideo = async () => {
  try {
    await videoElement.value.play()
    showPlayHint.value = false
  } catch (error) {
    console.error('播放失败:', error)
  }
}

const seek = (event) => {
  const progressBar = event.currentTarget
  const rect = progressBar.getBoundingClientRect()
  const percent = (event.clientX - rect.left) / rect.width
  const seekTime = percent * duration.value
  
  videoElement.value.currentTime = seekTime
  currentTime.value = seekTime
}

const changePlaybackRate = () => {
  const rates = [0.5, 0.75, 1, 1.25, 1.5, 2]
  const currentIndex = rates.indexOf(playbackRate.value)
  const nextIndex = (currentIndex + 1) % rates.length
  
  playbackRate.value = rates[nextIndex]
  videoElement.value.playbackRate = playbackRate.value
}

const toggleMute = () => {
  isMuted.value = !isMuted.value
  videoElement.value.muted = isMuted.value
}

const toggleFullscreen = () => {
  if (document.fullscreenElement) {
    document.exitFullscreen()
  } else {
    videoPlayer.value.requestFullscreen()
  }
}

// 进度跟踪
const startProgressTracking = () => {
  if (progressUpdateInterval.value) {
    clearInterval(progressUpdateInterval.value)
  }
  
  progressUpdateInterval.value = setInterval(() => {
    updateProgress()
  }, 10000) // 每10秒更新一次
}

const updateProgress = async () => {
  const progress = (currentTime.value / duration.value) * 100
  
  try {
    await request.put('/api/learning/progress', {
      lessonId: props.lessonId,
      progress: Math.min(progress, 100),
      duration: Math.floor(currentTime.value - lastProgressTime.value),
      position: Math.floor(currentTime.value)
    })
    
    emit('progress-update', {
      lessonId: props.lessonId,
      progress: progress,
      currentTime: currentTime.value
    })
  } catch (error) {
    console.error('更新进度失败:', error)
  }
}

// 笔记功能
const addNote = async () => {
  if (!newNote.value.trim()) return
  
  try {
    const response = await request.post('/api/learning/notes', {
      lessonId: props.lessonId,
      content: newNote.value,
      timestamp: Math.floor(currentTime.value)
    })
    
    notes.value.push(response.data)
    newNote.value = ''
  } catch (error) {
    console.error('添加笔记失败:', error)
  }
}

const seekToNote = (timestamp) => {
  videoElement.value.currentTime = timestamp
  currentTime.value = timestamp
}

// 工具函数
const formatTime = (seconds) => {
  const hours = Math.floor(seconds / 3600)
  const minutes = Math.floor((seconds % 3600) / 60)
  const secs = Math.floor(seconds % 60)
  
  if (hours > 0) {
    return `${hours}:${minutes.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`
  }
  return `${minutes}:${secs.toString().padStart(2, '0')}`
}

// 加载笔记
const loadNotes = async () => {
  try {
    const response = await request.get(`/api/learning/notes/${props.lessonId}`)
    notes.value = response.data
  } catch (error) {
    console.error('加载笔记失败:', error)
  }
}

onMounted(() => {
  loadNotes()
})

onUnmounted(() => {
  if (progressUpdateInterval.value) {
    clearInterval(progressUpdateInterval.value)
  }
  updateProgress() // 最后更新一次进度
})
</script>

<style scoped>
.video-player-container {
  position: relative;
  background: #000;
  border-radius: 8px;
  overflow: hidden;
}

.video-player {
  position: relative;
  width: 100%;
  height: 0;
  padding-bottom: 56.25%; /* 16:9 比例 */
}

.video-player video {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
}

.video-controls {
  position: absolute;
  bottom: 0;
  left: 0;
  right: 0;
  background: linear-gradient(transparent, rgba(0,0,0,0.8));
  padding: 20px 16px 16px;
  color: white;
}

.progress-container {
  margin-bottom: 12px;
}

.progress-bar {
  position: relative;
  height: 4px;
  background: rgba(255,255,255,0.3);
  border-radius: 2px;
  cursor: pointer;
}

.progress-buffer,
.progress-played {
  position: absolute;
  top: 0;
  left: 0;
  height: 100%;
  border-radius: 2px;
}

.progress-buffer {
  background: rgba(255,255,255,0.5);
}

.progress-played {
  background: #1976d2;
}

.progress-thumb {
  position: absolute;
  top: -6px;
  width: 16px;
  height: 16px;
  background: #1976d2;
  border-radius: 50%;
  transform: translateX(-50%);
}

.control-buttons {
  display: flex;
  align-items: center;
  gap: 8px;
}

.time-display {
  font-size: 14px;
  margin-left: 8px;
}

.playback-rate {
  font-size: 12px;
  min-width: 30px;
  text-align: center;
}

.notes-sidebar {
  position: absolute;
  top: 0;
  right: 0;
  width: 300px;
  height: 100%;
  background: rgba(255, 255, 255, 0.95);
  backdrop-filter: blur(10px);
  display: flex;
  flex-direction: column;
}

.notes-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 16px;
  border-bottom: 1px solid #e0e0e0;
}

.notes-content {
  flex: 1;
  overflow-y: auto;
  padding: 16px;
}

.note-item {
  margin-bottom: 16px;
  padding: 12px;
  background: #f5f5f5;
  border-radius: 8px;
}

.note-time {
  color: #1976d2;
  font-size: 12px;
  cursor: pointer;
  margin-bottom: 4px;
}

.note-time:hover {
  text-decoration: underline;
}

.note-text {
  font-size: 14px;
  line-height: 1.4;
}

.add-note {
  padding: 16px;
  border-top: 1px solid #e0e0e0;
}

.play-hint {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  text-align: center;
  color: white;
  pointer-events: none;
}

.play-hint p {
  margin-top: 8px;
  font-size: 16px;
}
</style>
```

### 模块五：业绩评价体系

#### 2.5.1 数据库设计

```sql
-- 评价维度表
CREATE TABLE evaluation_dimension (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(50) NOT NULL COMMENT '维度名称',
    code VARCHAR(20) NOT NULL UNIQUE COMMENT '维度代码',
    description TEXT COMMENT '维度描述',
    weight DECIMAL(5,2) NOT NULL COMMENT '权重(0-100)',
    parent_id INT DEFAULT 0 COMMENT '父级维度',
    level TINYINT DEFAULT 1 COMMENT '层级',
    sort_order INT DEFAULT 0 COMMENT '排序',
    status TINYINT DEFAULT 1 COMMENT '状态',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) COMMENT '评价维度表';

-- 评价指标表
CREATE TABLE evaluation_indicator (
    id INT PRIMARY KEY AUTO_INCREMENT,
    dimension_id INT NOT NULL COMMENT '所属维度ID',
    name VARCHAR(100) NOT NULL COMMENT '指标名称',
    code VARCHAR(30) NOT NULL COMMENT '指标代码',
    data_type VARCHAR(20) NOT NULL COMMENT '数据类型(number/text/enum/file)',
    unit VARCHAR(20) COMMENT '计量单位',
    calculation_method TEXT COMMENT '计算方法',
    weight DECIMAL(5,2) NOT NULL COMMENT '权重',
    max_score DECIMAL(6,2) DEFAULT 100 COMMENT '最高分值',
    scoring_rule TEXT COMMENT '评分规则',
    data_source VARCHAR(50) COMMENT '数据来源',
    auto_calculate BOOLEAN DEFAULT FALSE COMMENT '是否自动计算',
    sort_order INT DEFAULT 0 COMMENT '排序',
    status TINYINT DEFAULT 1 COMMENT '状态',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (dimension_id) REFERENCES evaluation_dimension(id),
    UNIQUE KEY uk_dimension_code (dimension_id, code)
) COMMENT '评价指标表';

-- 评价周期表
CREATE TABLE evaluation_period (
    id INT PRIMARY KEY AUTO_INCREMENT,
    name VARCHAR(100) NOT NULL COMMENT '周期名称',
    period_type VARCHAR(20) NOT NULL COMMENT '周期类型(annual/semester/monthly)',
    start_date DATE NOT NULL COMMENT '开始日期',
    end_date DATE NOT NULL COMMENT '结束日期',
    status VARCHAR(20) DEFAULT 'active' COMMENT '状态',
    description TEXT COMMENT '描述',
    created_by BIGINT COMMENT '创建人',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) COMMENT '评价周期表';

-- 用户评价记录表
CREATE TABLE user_evaluation (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '被评价用户ID',
    period_id INT NOT NULL COMMENT '评价周期ID',
    evaluator_id BIGINT COMMENT '评价人ID',
    evaluation_type VARCHAR(20) DEFAULT 'regular' COMMENT '评价类型',
    total_score DECIMAL(8,2) DEFAULT 0 COMMENT '总分',
    weighted_score DECIMAL(8,2) DEFAULT 0 COMMENT '加权总分',
    ranking INT COMMENT '排名',
    level VARCHAR(20) COMMENT '等级',
    status VARCHAR(20) DEFAULT 'draft' COMMENT '状态',
    submit_time TIMESTAMP NULL COMMENT '提交时间',
    review_time TIMESTAMP NULL COMMENT '审核时间',
    reviewer_id BIGINT COMMENT '审核人ID',
    comments TEXT COMMENT '评价意见',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (period_id) REFERENCES evaluation_period(id),
    UNIQUE KEY uk_user_period (user_id, period_id)
) COMMENT '用户评价记录表';

-- 指标得分详情表
CREATE TABLE indicator_score (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    evaluation_id BIGINT NOT NULL COMMENT '评价记录ID',
    indicator_id INT NOT NULL COMMENT '指标ID',
    original_value VARCHAR(500) COMMENT '原始数值',
    score DECIMAL(6,2) DEFAULT 0 COMMENT '得分',
    evidence_files TEXT COMMENT '佐证材料',
    evaluator_comment TEXT COMMENT '评价说明',
    auto_calculated BOOLEAN DEFAULT FALSE COMMENT '是否自动计算',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (evaluation_id) REFERENCES user_evaluation(id) ON DELETE CASCADE,
    FOREIGN KEY (indicator_id) REFERENCES evaluation_indicator(id),
    UNIQUE KEY uk_evaluation_indicator (evaluation_id, indicator_id)
) COMMENT '指标得分详情表';

-- 业绩数据表
CREATE TABLE performance_data (
    id BIGINT PRIMARY KEY AUTO_INCREMENT,
    user_id BIGINT NOT NULL COMMENT '用户ID',
    data_type VARCHAR(50) NOT NULL COMMENT '数据类型',
    data_key VARCHAR(100) NOT NULL COMMENT '数据键',
    data_value TEXT COMMENT '数据值',
    data_date DATE COMMENT '数据日期',
    source VARCHAR(50) COMMENT '数据来源',
    status VARCHAR(20) DEFAULT 'valid' COMMENT '状态',
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX idx_user_type (user_id, data_type),
    INDEX idx_user_date (user_id, data_date),
    INDEX idx_type_key (data_type, data_key)
) COMMENT '业绩数据表';
```

#### 2.5.2 自动化评分系统

```java
@Service
public class AutoEvaluationService {
    
    @Autowired
    private UserEvaluationMapper evaluationMapper;
    
    @Autowired
    private IndicatorScoreMapper indicatorScoreMapper;
    
    @Autowired
    private PerformanceDataMapper performanceDataMapper;
    
    @Autowired
    private EvaluationIndicatorMapper indicatorMapper;
    
    // 自动计算用户评价
    @Transactional
    public void calculateUserEvaluation(Long userId, Integer periodId) {
        UserEvaluation evaluation = evaluationMapper.findByUserAndPeriod(userId, periodId);
        if (evaluation == null) {
            evaluation = createEvaluation(userId, periodId);
        }
        
        List<EvaluationIndicator> indicators = indicatorMapper.findAllActive();
        
        double totalScore = 0;
        double totalWeight = 0;
        
        for (EvaluationIndicator indicator : indicators) {
            if (indicator.getAutoCalculate()) {
                IndicatorScore score = calculateIndicatorScore(evaluation.getId(), indicator, userId, periodId);
                totalScore += score.getScore() * indicator.getWeight() / 100;
                totalWeight += indicator.getWeight();
            }
        }
        
        evaluation.setTotalScore(BigDecimal.valueOf(totalScore));
        evaluation.setWeightedScore(BigDecimal.valueOf(totalScore / totalWeight * 100));
        evaluation.setLevel(determineLevel(evaluation.getWeightedScore()));
        
        evaluationMapper.updateById(evaluation);
        
        // 更新排名
        updateRankings(periodId);
    }
    
    // 计算单个指标得分
    private IndicatorScore calculateIndicatorScore(Long evaluationId, 
                                                   EvaluationIndicator indicator, 
                                                   Long userId, 
                                                   Integer periodId) {
        
        IndicatorScore indicatorScore = indicatorScoreMapper.findByEvaluationAndIndicator(
                evaluationId, indicator.getId());
        
        if (indicatorScore == null) {
            indicatorScore = new IndicatorScore();
            indicatorScore.setEvaluationId(evaluationId);
            indicatorScore.setIndicatorId(indicator.getId());
            indicatorScore.setAutoCalculated(true);
        }
        
        // 根据指标类型计算得分
        double score = 0;
        String originalValue = "";
        
        switch (indicator.getCode()) {
            case "RESEARCH_PAPERS":
                score = calculatePaperScore(userId, periodId, indicator);
                originalValue = String.valueOf(getPaperCount(userId, periodId));
                break;
                
            case "TEACHING_HOURS":
                score = calculateTeachingScore(userId, periodId, indicator);
                originalValue = String.valueOf(getTeachingHours(userId, periodId));
                break;
                
            case "RESEARCH_FUNDING":
                score = calculateFundingScore(userId, periodId, indicator);
                originalValue = String.valueOf(getFundingAmount(userId, periodId));
                break;
                
            case "STUDENT_EVALUATION":
                score = calculateStudentEvaluationScore(userId, periodId, indicator);
                originalValue = String.valueOf(getAverageStudentRating(userId, periodId));
                break;
                
            case "INNOVATION_PROJECTS":
                score = calculateInnovationScore(userId, periodId, indicator);
                originalValue = String.valueOf(getInnovationProjectCount(userId, periodId));
                break;
                
            default:
                score = calculateCustomScore(userId, periodId, indicator);
                originalValue = getCustomValue(userId, periodId, indicator);
        }
        
        indicatorScore.setScore(BigDecimal.valueOf(Math.min(score, indicator.getMaxScore().doubleValue())));
        indicatorScore.setOriginalValue(originalValue);
        
        if (indicatorScore.getId() == null) {
            indicatorScoreMapper.insert(indicatorScore);
        } else {
            indicatorScoreMapper.updateById(indicatorScore);
        }
        
        return indicatorScore;
    }
    
    // 论文评分算法
    private double calculatePaperScore(Long userId, Integer periodId, EvaluationIndicator indicator) {
        List<PerformanceData> papers = performanceDataMapper.findByUserAndTypeInPeriod(
                userId, "RESEARCH_PAPER", getPeriodDateRange(periodId));
        
        double score = 0;
        for (PerformanceData paper : papers) {
            // 根据期刊级别和影响因子计算分数
            String journalLevel = extractJsonValue(paper.getDataValue(), "journal_level");
            double impactFactor = extractJsonDouble(paper.getDataValue(), "impact_factor");
            
            switch (journalLevel) {
                case "SCI_Q1":
                    score += 100 + impactFactor * 10;
                    break;
                case "SCI_Q2":
                    score += 80 + impactFactor * 8;
                    break;
                case "SCI_Q3":
                    score += 60 + impactFactor * 6;
                    break;
                case "SCI_Q4":
                    score += 40 + impactFactor * 4;
                    break;
                case "CORE":
                    score += 50;
                    break;
                case "CSSCI":
                    score += 30;
                    break;
                default:
                    score += 20;
            }
        }
        
        return score;
    }
    
    // 教学工作量评分
    private double calculateTeachingScore(Long userId, Integer periodId, EvaluationIndicator indicator) {
        List<PerformanceData> teachingData = performanceDataMapper.findByUserAndTypeInPeriod(
                userId, "TEACHING_HOURS", getPeriodDateRange(periodId));
        
        double totalHours = teachingData.stream()
                .mapToDouble(data -> Double.parseDouble(data.getDataValue()))
                .sum();
        
        // 基础工作量要求
        double baseHours = 320; // 年度基础工作量
        double score = 0;
        
        if (totalHours >= baseHours) {
            score = 100;
            // 超额部分加分
            if (totalHours > baseHours * 1.2) {
                score += (totalHours - baseHours * 1.2) / baseHours * 50;
            }
        } else {
            score = totalHours / baseHours * 100;
        }
        
        return score;
    }
    
    // 科研经费评分
    private double calculateFundingScore(Long userId, Integer periodId, EvaluationIndicator indicator) {
        List<PerformanceData> fundingData = performanceDataMapper.findByUserAndTypeInPeriod(
                userId, "RESEARCH_FUNDING", getPeriodDateRange(periodId));
        
        double totalFunding = fundingData.stream()
                .mapToDouble(data -> {
                    String role = extractJsonValue(data.getDataValue(), "role");
                    double amount = extractJsonDouble(data.getDataValue(), "amount");
                    
                    // 根据角色计算贡献度
                    switch (role) {
                        case "PI": return amount; // 主持人全额计分
                        case "CO_PI": return amount * 0.5; // 共同主持人50%
                        case "PARTICIPANT": return amount * 0.2; // 参与人20%
                        default: return 0;
                    }
                })
                .sum();
        
        // 按经费额度分档计分
        double score = 0;
        if (totalFunding >= 1000000) { // 100万以上
            score = 100;
        } else if (totalFunding >= 500000) { // 50-100万
            score = 80;
        } else if (totalFunding >= 200000) { // 20-50万
            score = 60;
        } else if (totalFunding >= 100000) { // 10-20万
            score = 40;
        } else if (totalFunding >= 50000) { // 5-10万
            score = 20;
        }
        
        return score;
    }
    
    // 学生评教评分
    private double calculateStudentEvaluationScore(Long userId, Integer periodId, EvaluationIndicator indicator) {
        List<PerformanceData> evaluations = performanceDataMapper.findByUserAndTypeInPeriod(
                userId, "STUDENT_EVALUATION", getPeriodDateRange(periodId));
        
        if (evaluations.isEmpty()) return 60; // 默认及格分
        
        double averageRating = evaluations.stream()
                .mapToDouble(data -> extractJsonDouble(data.getDataValue(), "rating"))
                .average()
                .orElse(0);
        
        // 5分制转100分制，并适当调整
        double score = (averageRating - 3) / 2 * 50 + 75; // 3分对应75分，5分对应100分
        
        return Math.max(0, Math.min(100, score));
    }
    
    // 更新排名
    private void updateRankings(Integer periodId) {
        List<UserEvaluation> evaluations = evaluationMapper.findByPeriodOrderByScore(periodId);
        
        for (int i = 0; i < evaluations.size(); i++) {
            UserEvaluation evaluation = evaluations.get(i);
            evaluation.setRanking(i + 1);
            evaluationMapper.updateById(evaluation);
        }
    }
    
    // 确定等级
    private String determineLevel(BigDecimal score) {
        double s = score.doubleValue();
        if (s >= 95) return "优秀";
        if (s >= 85) return "良好";
        if (s >= 75) return "中等";
        if (s >= 60) return "及格";
        return "不及格";
    }
    
    // 工具方法
    private String extractJsonValue(String json, String key) {
        // JSON解析逻辑
        try {
            ObjectMapper mapper = new ObjectMapper();
            JsonNode node = mapper.readTree(json);
            return node.get(key).asText();
        } catch (Exception e) {
            return "";
        }
    }
    
    private double extractJsonDouble(String json, String key) {
        try {
            ObjectMapper mapper = new ObjectMapper();
            JsonNode node = mapper.readTree(json);
            return node.get(key).asDouble();
        } catch (Exception e) {
            return 0.0;
        }
    }
}

// 评价任务调度
@Component
public class EvaluationScheduler {
    
    @Autowired
    private AutoEvaluationService autoEvaluationService;
    
    @Autowired
    private UserService userService;
    
    @Autowired
    private EvaluationPeriodService periodService;
    
    // 每周日凌晨2点执行自动评价
    @Scheduled(cron = "0 0 2 * * SUN")
    public void weeklyEvaluation() {
        log.info("开始执行周度自动评价");
        
        EvaluationPeriod currentPeriod = periodService.getCurrentPeriod();
        if (currentPeriod == null) {
            log.warn("未找到当前评价周期");
            return;
        }
        
        List<User> activeUsers = userService.getActiveUsers();
        
        for (User user : activeUsers) {
            try {
                autoEvaluationService.calculateUserEvaluation(user.getId(), currentPeriod.getId());
                log.info("用户 {} 自动评价完成", user.getUsername());
            } catch (Exception e) {
                log.error("用户 {} 自动评价失败", user.getUsername(), e);
            }
        }
        
        log.info("周度自动评价执行完成");
    }
    
    // 每月1号生成月度报告
    @Scheduled(cron = "0 0 3 1 * ?")
    public void monthlyReport() {
        log.info("开始生成月度评价报告");
        // 生成报告逻辑
    }
}
```

------

## 三、项目实施计划

### 3.1 开发时间安排

**第一天：中医药知识图谱核心开发**

- 上午：学习Neo4j，设计图数据库Schema
- 下午：实现知识图谱后端API和前端可视化
- 晚上：导入基础中医药数据，测试图谱查询

**第二天：AI科研助手开发**

- 上午：集成大语言模型API，实现智能问答功能
- 下午：开发文献检索和研究方案生成功能
- 晚上：前端AI对话界面开发和测试

**第三天：方剂管理系统**

- 上午：完善方剂数据库设计，导入方剂数据
- 下午：实现方剂查询、推荐和分析功能
- 晚上：开发方剂对比和配伍分析界面

**第四天：教学科研一体化**

- 上午：在线学习系统开发（视频播放、进度跟踪）
- 下午：科研项目管理和成果展示功能
- 晚上：学习统计和科研数据可视化

**第五天：业绩评价体系**

- 上午：评价指标体系设计和自动计算逻辑
- 下午：评价流程和审核功能实现
- 晚上：评价报告生成和数据展示

**第六天：系统集成与优化**

- 上午：模块集成，统一用户体验
- 下午：性能优化，安全加固
- 晚上：移动端和桌面端适配

**第七天：测试与部署**

- 上午：功能测试，bug修复
- 下午：系统部署，演示准备
- 晚上：文档整理，答辩PPT制作

### 3.2 技术选型与学习指南

#### 3.2.1 后端技术栈

```xml
<!-- 核心依赖 -->
<dependencies>
    <!-- SpringBoot基础 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-web</artifactId>
    </dependency>
    
    <!-- 数据库相关 -->
    <dependency>
        <groupId>com.baomidou</groupId>
        <artifactId>mybatis-plus-boot-starter</artifactId>
        <version>3.5.3</version>
    </dependency>
    
    <!-- Neo4j图数据库 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-neo4j</artifactId>
    </dependency>
    
    <!-- Redis缓存 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-redis</artifactId>
    </dependency>
    
    <!-- Elasticsearch全文检索 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-data-elasticsearch</artifactId>
    </dependency>
    
    <!-- 安全认证 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-security</artifactId>
    </dependency>
    
    <!-- JWT Token -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt</artifactId>
        <version>0.9.1</version>
    </dependency>
    
    <!-- 文件上传 -->
    <dependency>
        <groupId>com.aliyun.oss</groupId>
        <artifactId>aliyun-sdk-oss</artifactId>
        <version>3.15.1</version>
    </dependency>
    
    <!-- HTTP客户端 -->
    <dependency>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-webflux</artifactId>
    </dependency>
</dependencies>
```

#### 3.2.2 前端技术栈

```json
{
  "dependencies": {
    "vue": "^3.3.0",
    "vue-router": "^4.2.0",
    "pinia": "^2.1.0",
    "vuetify": "^3.3.0",
    "@mdi/font": "^7.2.0",
    "axios": "^1.4.0",
    "echarts": "^5.4.0",
    "d3": "^7.8.0",
    "cytoscape": "^3.25.0",
    "video.js": "^8.3.0",
    "marked": "^5.1.0",
    "lodash": "^4.17.0"
  },
  "devDependencies": {
    "@vitejs/plugin-vue": "^4.2.0",
    "vite": "^4.3.0",
    "sass": "^1.63.0"
  }
}
```

#### 3.2.3 学习路径指南

**图数据库Neo4j学习**：

1. 学习Cypher查询语言基础语法
2. 理解节点、关系、属性的概念
3. 掌握图数据库建模方法
4. 学习SpringBoot集成Neo4j
5. 实践复杂关系查询和图算法

**Vue3生态学习**：

1. 掌握Composition API核心概念
2. 学习Pinia状态管理
3. 熟悉Vuetify3组件库使用
4. 掌握Vue Router 4路由管理
5. 学习前端工程化配置

**数据可视化学习**：

1. 学习ECharts基础图表配置
2. 掌握D3.js数据绑定和DOM操作
3. 学习Cytoscape.js网络图可视化
4. 实践交互式图表开发

------

## 四、数据库表设计代码

### 4.1 MySQL数据库完整设计

```sql
-- ===================================
-- 生物医药数字信息系统 - 数据库设计
-- ===================================

-- 设置字符集
SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ===================================
-- 用户权限模块
-- ===================================

-- 用户表
CREATE TABLE `user` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `username` VARCHAR(50) NOT NULL UNIQUE COMMENT '用户名',
    `password_hash` VARCHAR(255) NOT NULL COMMENT '密码哈希',
    `email` VARCHAR(100) UNIQUE COMMENT '邮箱',
    `phone` VARCHAR(20) COMMENT '手机号',
    `real_name` VARCHAR(50) COMMENT '真实姓名',
    `avatar_url` VARCHAR(255) COMMENT '头像URL',
    `status` TINYINT DEFAULT 1 COMMENT '状态 1-正常 0-禁用',
    `last_login_time` TIMESTAMP NULL COMMENT '最后登录时间',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX `idx_username` (`username`),
    INDEX `idx_email` (`email`),
    INDEX `idx_phone` (`phone`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户表';

-- 角色表
CREATE TABLE `role` (
    `id` INT PRIMARY KEY AUTO_INCREMENT,
    `name` VARCHAR(50) NOT NULL UNIQUE COMMENT '角色名称',
    `code` VARCHAR(20) NOT NULL UNIQUE COMMENT '角色代码',
    `description` TEXT COMMENT '角色描述',
    `status` TINYINT DEFAULT 1 COMMENT '状态',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='角色表';

-- 权限表
CREATE TABLE `permission` (
    `id` INT PRIMARY KEY AUTO_INCREMENT,
    `name` VARCHAR(50) NOT NULL COMMENT '权限名称',
    `code` VARCHAR(50) NOT NULL UNIQUE COMMENT '权限代码',
    `type` VARCHAR(20) NOT NULL COMMENT '权限类型(menu/button/api)',
    `parent_id` INT DEFAULT 0 COMMENT '父级权限ID',
    `path` VARCHAR(200) COMMENT '路径',
    `icon` VARCHAR(50) COMMENT '图标',
    `sort_order` INT DEFAULT 0 COMMENT '排序',
    `status` TINYINT DEFAULT 1 COMMENT '状态',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='权限表';

-- 用户角色关联表
CREATE TABLE `user_role` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `user_id` BIGINT NOT NULL COMMENT '用户ID',
    `role_id` INT NOT NULL COMMENT '角色ID',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON DELETE CASCADE,
    FOREIGN KEY (`role_id`) REFERENCES `role`(`id`) ON DELETE CASCADE,
    UNIQUE KEY `uk_user_role` (`user_id`, `role_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户角色关联表';

-- 角色权限关联表
CREATE TABLE `role_permission` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `role_id` INT NOT NULL COMMENT '角色ID',
    `permission_id` INT NOT NULL COMMENT '权限ID',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (`role_id`) REFERENCES `role`(`id`) ON DELETE CASCADE,
    FOREIGN KEY (`permission_id`) REFERENCES `permission`(`id`) ON DELETE CASCADE,
    UNIQUE KEY `uk_role_permission` (`role_id`, `permission_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='角色权限关联表';

-- ===================================
-- 中药材地理信息模块（原有，保持兼容）
-- ===================================

-- 药材基本信息表
CREATE TABLE `herb` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `name` VARCHAR(64) NOT NULL UNIQUE COMMENT '药材名称',
    `scientific_name` VARCHAR(128) COMMENT '学名',
    `alias` VARCHAR(200) COMMENT '别名',
    `family` VARCHAR(50) COMMENT '科名',
    `genus` VARCHAR(50) COMMENT '属名',
    `nature` VARCHAR(50) COMMENT '性味',
    `meridian` VARCHAR(100) COMMENT '归经',
    `effect` TEXT COMMENT '功效',
    `usage` VARCHAR(200) COMMENT '用法用量',
    `taboo` TEXT COMMENT '禁忌',
    `description` TEXT COMMENT '简介/药用价值描述',
    `image_urls` JSON COMMENT '图片URL列表',
    `status` TINYINT DEFAULT 1 COMMENT '状态',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX `idx_name` (`name`),
    INDEX `idx_pinyin` (`scientific_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='药材基本信息表';

-- 药材地理分布表
CREATE TABLE `herb_location` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `herb_id` BIGINT NOT NULL COMMENT '药材ID（外键）',
    `longitude` DECIMAL(10,7) NOT NULL COMMENT '经度',
    `latitude` DECIMAL(10,7) NOT NULL COMMENT '纬度',
    `province` VARCHAR(32) COMMENT '省份',
    `city` VARCHAR(32) COMMENT '城市',
    `county` VARCHAR(32) COMMENT '县区',
    `address` VARCHAR(255) COMMENT '详细地址',
    `altitude` INT COMMENT '海拔高度',
    `climate_type` VARCHAR(50) COMMENT '气候类型',
    `soil_type` VARCHAR(50) COMMENT '土壤类型',
    `observation_year` INT NOT NULL COMMENT '观测/采集年份',
    `quality_grade` VARCHAR(20) COMMENT '品质等级',
    `yield_per_mu` DECIMAL(8,2) COMMENT '亩产量(kg)',
    `is_geo_authentic` TINYINT DEFAULT 0 COMMENT '是否道地药材',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (`herb_id`) REFERENCES `herb`(`id`) ON DELETE CASCADE,
    INDEX `idx_herb` (`herb_id`),
    INDEX `idx_location` (`longitude`, `latitude`),
    INDEX `idx_province` (`province`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='药材地理分布表';

-- 药材图片表
CREATE TABLE `herb_image` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `herb_id` BIGINT NOT NULL COMMENT '药材ID（外键）',
    `location_id` BIGINT COMMENT '观测点ID（可选外键）',
    `url` VARCHAR(255) NOT NULL COMMENT '图片地址URL',
    `is_primary` TINYINT DEFAULT 0 COMMENT '是否为主图（0-否，1-是）',
    `image_type` VARCHAR(20) COMMENT '图片类型(plant/flower/leaf/root/seed)',
    `description` VARCHAR(255) COMMENT '图片描述',
    `upload_user_id` BIGINT COMMENT '上传用户ID',
    `uploaded_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (`herb_id`) REFERENCES `herb`(`id`) ON DELETE CASCADE,
    FOREIGN KEY (`location_id`) REFERENCES `herb_location`(`id`) ON DELETE SET NULL,
    INDEX `idx_herb` (`herb_id`),
    INDEX `idx_location` (`location_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='药材图片表';

-- 药材生长数据表
CREATE TABLE `herb_growth_data` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `location_id` BIGINT NOT NULL COMMENT '观测点ID（外键）',
    `metric_name` VARCHAR(50) NOT NULL COMMENT '指标名称',
    `metric_value` VARCHAR(100) NOT NULL COMMENT '指标值',
    `metric_unit` VARCHAR(20) COMMENT '指标单位',
    `measurement_date` DATE COMMENT '测量日期',
    `recorder_id` BIGINT COMMENT '记录人ID',
    `recorded_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (`location_id`) REFERENCES `herb_location`(`id`) ON DELETE CASCADE,
    INDEX `idx_location` (`location_id`),
    INDEX `idx_metric` (`metric_name`),
    INDEX `idx_date` (`measurement_date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='药材生长数据表';

-- ===================================
-- 方剂管理模块
-- ===================================

-- 方剂分类表
CREATE TABLE `formula_category` (
    `id` INT PRIMARY KEY AUTO_INCREMENT,
    `name` VARCHAR(50) NOT NULL COMMENT '分类名称',
    `parent_id` INT DEFAULT 0 COMMENT '父级分类ID',
    `sort_order` INT DEFAULT 0 COMMENT '排序',
    `description` TEXT COMMENT '分类描述',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='方剂分类表';

-- 方剂基本信息表
CREATE TABLE `formula` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `name` VARCHAR(100) NOT NULL COMMENT '方剂名称',
    `alias` VARCHAR(200) COMMENT '别名',
    `source` VARCHAR(100) COMMENT '出处典籍',
    `dynasty` VARCHAR(50) COMMENT '朝代',
    `author` VARCHAR(100) COMMENT '创方人',
    `category_id` INT COMMENT '分类ID',
    `composition` TEXT COMMENT '药物组成',
    `preparation` TEXT COMMENT '制法',
    `usage` TEXT COMMENT '用法',
    `dosage_form` VARCHAR(50) COMMENT '剂型',
    `function_effect` TEXT COMMENT '功用',
    `main_treatment` TEXT COMMENT '主治',
    `clinical_application` TEXT COMMENT '临床应用',
    `pharmacological_action` TEXT COMMENT '药理作用',
    `contraindication` TEXT COMMENT '禁忌',
    `caution` TEXT COMMENT '注意事项',
    `modern_research` TEXT COMMENT '现代研究',
    `usage_frequency` INT DEFAULT 0 COMMENT '使用频次统计',
    `efficacy_rating` DECIMAL(3,1) DEFAULT 0 COMMENT '疗效评分',
    `safety_level` TINYINT DEFAULT 3 COMMENT '安全等级 1-5',
    `evidence_level` VARCHAR(20) COMMENT '循证等级',
    `status` TINYINT DEFAULT 1 COMMENT '状态 1-正常 0-禁用',
    `created_by` BIGINT COMMENT '创建人',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (`category_id`) REFERENCES `formula_category`(`id`),
    INDEX `idx_name` (`name`),
    INDEX `idx_source` (`source`),
    INDEX `idx_category` (`category_id`),
    INDEX `idx_efficacy` (`efficacy_rating`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='方剂基本信息表';

-- 方剂药物组成表
CREATE TABLE `formula_herb` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `formula_id` BIGINT NOT NULL COMMENT '方剂ID',
    `herb_id` BIGINT NOT NULL COMMENT '药材ID',
    `herb_name` VARCHAR(50) NOT NULL COMMENT '药材名称',
    `dosage` VARCHAR(20) COMMENT '用量',
    `unit` VARCHAR(10) COMMENT '单位',
    `role` VARCHAR(20) COMMENT '配伍作用(君臣佐使)',
    `processing` VARCHAR(50) COMMENT '炮制方法',
    `usage_note` TEXT COMMENT '用法备注',
    `sort_order` INT DEFAULT 0 COMMENT '排序',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (`formula_id`) REFERENCES `formula`(`id`) ON DELETE CASCADE,
    FOREIGN KEY (`herb_id`) REFERENCES `herb`(`id`),
    INDEX `idx_formula` (`formula_id`),
    INDEX `idx_herb` (`herb_id`),
    INDEX `idx_role` (`role`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='方剂药物组成表';

-- 疾病信息表
CREATE TABLE `disease` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `name` VARCHAR(100) NOT NULL COMMENT '疾病名称',
    `code` VARCHAR(50) COMMENT '疾病编码(ICD-10)',
    `category` VARCHAR(50) COMMENT '疾病分类',
    `symptoms` TEXT COMMENT '主要症状',
    `pathogenesis` TEXT COMMENT '病因病机',
    `syndrome_differentiation` TEXT COMMENT '辨证要点',
    `treatment_principle` TEXT COMMENT '治疗原则',
    `prevention` TEXT COMMENT '预防措施',
    `prognosis` TEXT COMMENT '预后',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX `idx_name` (`name`),
    INDEX `idx_code` (`code`),
    INDEX `idx_category` (`category`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='疾病信息表';

-- 方剂主治疾病关联表
CREATE TABLE `formula_disease` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `formula_id` BIGINT NOT NULL COMMENT '方剂ID',
    `disease_id` BIGINT NOT NULL COMMENT '疾病ID',
    `syndrome` VARCHAR(200) COMMENT '证候',
    `efficacy_level` TINYINT COMMENT '疗效等级 1-5',
    `evidence_level` VARCHAR(20) COMMENT '循证等级',
    `clinical_data` TEXT COMMENT '临床数据',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (`formula_id`) REFERENCES `formula`(`id`) ON DELETE CASCADE,
    FOREIGN KEY (`disease_id`) REFERENCES `disease`(`id`) ON DELETE CASCADE,
    INDEX `idx_formula` (`formula_id`),
    INDEX `idx_disease` (`disease_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='方剂主治疾病关联表';

-- 方剂临床验案表
CREATE TABLE `formula_case` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `formula_id` BIGINT NOT NULL COMMENT '方剂ID',
    `case_title` VARCHAR(200) COMMENT '医案标题',
    `patient_info` JSON COMMENT '患者信息(年龄/性别等)',
    `chief_complaint` TEXT COMMENT '主诉',
    `history_present` TEXT COMMENT '现病史',
    `physical_exam` TEXT COMMENT '体格检查',
    `tongue_pulse` TEXT COMMENT '舌脉',
    `tcm_diagnosis` TEXT COMMENT '中医诊断',
    `treatment_principle` TEXT COMMENT '治法',
    `prescription` TEXT COMMENT '处方',
    `follow_up` TEXT COMMENT '随访记录',
    `outcome` TEXT COMMENT '疗效',
    `doctor_name` VARCHAR(50) COMMENT '医生姓名',
    `hospital` VARCHAR(100) COMMENT '医院',
    `case_date` DATE COMMENT '医案日期',
    `source` VARCHAR(100) COMMENT '资料来源',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (`formula_id`) REFERENCES `formula`(`id`) ON DELETE CASCADE,
    INDEX `idx_formula` (`formula_id`),
    INDEX `idx_doctor` (`doctor_name`),
    INDEX `idx_date` (`case_date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='方剂临床验案表';

-- ===================================
-- 教学资源模块
-- ===================================

-- 课程分类表
CREATE TABLE `course_category` (
    `id` INT PRIMARY KEY AUTO_INCREMENT,
    `name` VARCHAR(50) NOT NULL COMMENT '分类名称',
    `parent_id` INT DEFAULT 0 COMMENT '父级分类',
    `icon` VARCHAR(100) COMMENT '图标',
    `sort_order` INT DEFAULT 0 COMMENT '排序',
    `description` TEXT COMMENT '描述',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='课程分类表';

-- 课程表
CREATE TABLE `course` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `title` VARCHAR(200) NOT NULL COMMENT '课程标题',
    `subtitle` VARCHAR(500) COMMENT '课程副标题',
    `category_id` INT NOT NULL COMMENT '分类ID',
    `teacher_id` BIGINT NOT NULL COMMENT '教师ID',
    `cover_image` VARCHAR(255) COMMENT '封面图片',
    `introduction` TEXT COMMENT '课程介绍',
    `objectives` TEXT COMMENT '学习目标',
    `prerequisites` TEXT COMMENT '先修要求',
    `difficulty_level` TINYINT DEFAULT 1 COMMENT '难度等级 1-5',
    `duration` INT COMMENT '课程时长(分钟)',
    `price` DECIMAL(10,2) DEFAULT 0 COMMENT '课程价格',
    `status` VARCHAR(20) DEFAULT 'draft' COMMENT '状态(draft/published/archived)',
    `view_count` INT DEFAULT 0 COMMENT '观看次数',
    `student_count` INT DEFAULT 0 COMMENT '学生数量',
    `rating` DECIMAL(3,1) DEFAULT 0 COMMENT '评分',
    `rating_count` INT DEFAULT 0 COMMENT '评分人数',
    `tags` VARCHAR(500) COMMENT '标签',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (`category_id`) REFERENCES `course_category`(`id`),
    FOREIGN KEY (`teacher_id`) REFERENCES `user`(`id`),
    INDEX `idx_category` (`category_id`),
    INDEX `idx_teacher` (`teacher_id`),
    INDEX `idx_status` (`status`),
    INDEX `idx_rating` (`rating`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='课程表';

-- 课程章节表
CREATE TABLE `course_chapter` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `course_id` BIGINT NOT NULL COMMENT '课程ID',
    `title` VARCHAR(200) NOT NULL COMMENT '章节标题',
    `description` TEXT COMMENT '章节描述',
    `sort_order` INT DEFAULT 0 COMMENT '排序',
    `duration` INT DEFAULT 0 COMMENT '时长',
    `status` VARCHAR(20) DEFAULT 'published' COMMENT '状态',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (`course_id`) REFERENCES `course`(`id`) ON DELETE CASCADE,
    INDEX `idx_course` (`course_id`),
    INDEX `idx_sort` (`sort_order`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='课程章节表';

-- 课程课时表
CREATE TABLE `course_lesson` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `chapter_id` BIGINT NOT NULL COMMENT '章节ID',
    `course_id` BIGINT NOT NULL COMMENT '课程ID',
    `title` VARCHAR(200) NOT NULL COMMENT '课时标题',
    `content_type` VARCHAR(20) NOT NULL COMMENT '内容类型(video/document/quiz/live)',
    `content_url` VARCHAR(500) COMMENT '内容地址',
    `content` LONGTEXT COMMENT '文本内容',
    `duration` INT DEFAULT 0 COMMENT '时长(秒)',
    `sort_order` INT DEFAULT 0 COMMENT '排序',
    `is_free` TINYINT DEFAULT 0 COMMENT '是否免费',
    `download_allowed` TINYINT DEFAULT 0 COMMENT '是否允许下载',
    `status` VARCHAR(20) DEFAULT 'published' COMMENT '状态',
    `view_count` INT DEFAULT 0 COMMENT '观看次数',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (`chapter_id`) REFERENCES `course_chapter`(`id`) ON DELETE CASCADE,
    FOREIGN KEY (`course_id`) REFERENCES `course`(`id`) ON DELETE CASCADE,
    INDEX `idx_chapter` (`chapter_id`),
    INDEX `idx_course` (`course_id`),
    INDEX `idx_type` (`content_type`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='课程课时表';

-- 学习记录表
CREATE TABLE `study_record` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `user_id` BIGINT NOT NULL COMMENT '用户ID',
    `course_id` BIGINT NOT NULL COMMENT '课程ID',
    `lesson_id` BIGINT NOT NULL COMMENT '课时ID',
    `progress` DECIMAL(5,2) DEFAULT 0 COMMENT '学习进度百分比',
    `study_duration` INT DEFAULT 0 COMMENT '学习时长(秒)',
    `completed_at` TIMESTAMP NULL COMMENT '完成时间',
    `last_position` INT DEFAULT 0 COMMENT '最后观看位置(秒)',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON DELETE CASCADE,
    FOREIGN KEY (`course_id`) REFERENCES `course`(`id`) ON DELETE CASCADE,
    FOREIGN KEY (`lesson_id`) REFERENCES `course_lesson`(`id`) ON DELETE CASCADE,
    UNIQUE KEY `uk_user_lesson` (`user_id`, `lesson_id`),
    INDEX `idx_user_course` (`user_id`, `course_id`),
    INDEX `idx_completed` (`completed_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='学习记录表';

-- 课程笔记表
CREATE TABLE `course_note` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `user_id` BIGINT NOT NULL COMMENT '用户ID',
    `lesson_id` BIGINT NOT NULL COMMENT '课时ID',
    `content` TEXT NOT NULL COMMENT '笔记内容',
    `timestamp` INT DEFAULT 0 COMMENT '视频时间点(秒)',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (`user_id`) REFERENCES `user`(`id`) ON DELETE CASCADE,
    FOREIGN KEY (`lesson_id`) REFERENCES `course_lesson`(`id`) ON DELETE CASCADE,
    INDEX `idx_user_lesson` (`user_id`, `lesson_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='课程笔记表';

-- ===================================
-- 科研管理模块
-- ===================================

-- 科研项目表
CREATE TABLE `research_project` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `project_name` VARCHAR(200) NOT NULL COMMENT '项目名称',
    `project_code` VARCHAR(50) COMMENT '项目编号',
    `project_type` VARCHAR(50) COMMENT '项目类型',
    `funding_source` VARCHAR(100) COMMENT '资助来源',
    `funding_amount` DECIMAL(12,2) COMMENT '资助金额',
    `principal_investigator` BIGINT COMMENT '项目负责人ID',
    `start_date` DATE COMMENT '开始日期',
    `end_date` DATE COMMENT '结束日期',
    `status` VARCHAR(20) DEFAULT 'active' COMMENT '状态(active/completed/suspended)',
    `abstract` TEXT COMMENT '项目摘要',
    `keywords` VARCHAR(500) COMMENT '关键词',
    `research_field` VARCHAR(100) COMMENT '研究领域',
    `achievements` TEXT COMMENT '项目成果',
    `progress_report` TEXT COMMENT '进展报告',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (`principal_investigator`) REFERENCES `user`(`id`),
    INDEX `idx_pi` (`principal_investigator`),
    INDEX `idx_status` (`status`),
    INDEX `idx_type` (`project_type`),
    INDEX `idx_dates` (`start_date`, `end_date`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='科研项目表';

-- 项目参与人员表
CREATE TABLE `project_member` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `project_id` BIGINT NOT NULL COMMENT '项目ID',
    `user_id` BIGINT NOT NULL COMMENT '用户ID',
    `role` VARCHAR(50) NOT NULL COMMENT '角色(PI/Co-PI/researcher/student)',
    `contribution_rate` DECIMAL(5,2) COMMENT '贡献度百分比',
    `join_date` DATE COMMENT '加入日期',
    `leave_date` DATE COMMENT '离开日期',
    `status` VARCHAR(20) DEFAULT 'active' COMMENT '状态',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (`project_id`) REFERENCES `research_project`(`id`) ON DELETE CASCADE,
    FOREIGN KEY (`user_id`) REFERENCES `user`(`id`),
    UNIQUE KEY `uk_project_user` (`project_id`, `user_id`),
    INDEX `idx_user` (`user_id`),
    INDEX `idx_role` (`role`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='项目参与人员表';

-- 科研成果表
CREATE TABLE `research_achievement` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `project_id` BIGINT COMMENT '关联项目ID',
    `achievement_type` VARCHAR(50) NOT NULL COMMENT '成果类型(paper/patent/award/book/software)',
    `title` VARCHAR(500) NOT NULL COMMENT '成果标题',
    `authors` TEXT COMMENT '作者',
    `first_author_id` BIGINT COMMENT '第一作者ID',
    `corresponding_author_id` BIGINT COMMENT '通讯作者ID',
    `publication` VARCHAR(200) COMMENT '发表期刊/出版社',
    `publish_date` DATE COMMENT '发表日期',
    `volume` VARCHAR(20) COMMENT '卷号',
    `issue` VARCHAR(20) COMMENT '期号',
    `page_range` VARCHAR(50) COMMENT '页码范围',
    `impact_factor` DECIMAL(6,3) COMMENT '影响因子',
    `citation_count` INT DEFAULT 0 COMMENT '引用次数',
    `doi` VARCHAR(100) COMMENT 'DOI',
    `abstract` TEXT COMMENT '摘要',
    `keywords` VARCHAR(500) COMMENT '关键词',
    `file_url` VARCHAR(500) COMMENT '文件地址',
    `status` VARCHAR(20) DEFAULT 'published' COMMENT '状态',
    `created_by` BIGINT COMMENT '创建人',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (`project_id`) REFERENCES `research_project`(`id`),
    FOREIGN KEY (`first_author_id`) REFERENCES `user`(`id`),
    FOREIGN KEY (`corresponding_author_id`) REFERENCES `user`(`id`),
    INDEX `idx_project` (`project_id`),
    INDEX `idx_type` (`achievement_type`),
    INDEX `idx_first_author` (`first_author_id`),
    INDEX `idx_date` (`publish_date`),
    INDEX `idx_impact` (`impact_factor`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='科研成果表';

-- 文献资料表
CREATE TABLE `literature` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `title` VARCHAR(500) NOT NULL COMMENT '文献标题',
    `authors` TEXT COMMENT '作者',
    `publication` VARCHAR(200) COMMENT '期刊/会议名称',
    `publish_year` INT COMMENT '发表年份',
    `volume` VARCHAR(20) COMMENT '卷号',
    `issue` VARCHAR(20) COMMENT '期号',
    `page_range` VARCHAR(50) COMMENT '页码',
    `doi` VARCHAR(100) COMMENT 'DOI',
    `pmid` VARCHAR(20) COMMENT 'PubMed ID',
    `abstract` TEXT COMMENT '摘要',
    `keywords` VARCHAR(500) COMMENT '关键词',
    `research_field` VARCHAR(100) COMMENT '研究领域',
    `impact_factor` DECIMAL(6,3) COMMENT '影响因子',
    `citation_count` INT DEFAULT 0 COMMENT '引用次数',
    `pdf_url` VARCHAR(500) COMMENT 'PDF地址',
    `source` VARCHAR(50) COMMENT '来源(PubMed/CNKI/WanFang)',
    `language` VARCHAR(10) DEFAULT 'zh' COMMENT '语言',
    `status` VARCHAR(20) DEFAULT 'active' COMMENT '状态',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX `idx_title` (`title`(100)),
    INDEX `idx_authors` (`authors`(100)),
    INDEX `idx_year` (`publish_year`),
    INDEX `idx_field` (`research_field`),
    INDEX `idx_source` (`source`),
    FULLTEXT `ft_content` (`title`, `abstract`, `keywords`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='文献资料表';

-- ===================================
-- 业绩评价模块
-- ===================================

-- 评价维度表
CREATE TABLE `evaluation_dimension` (
    `id` INT PRIMARY KEY AUTO_INCREMENT,
    `name` VARCHAR(50) NOT NULL COMMENT '维度名称',
    `code` VARCHAR(20) NOT NULL UNIQUE COMMENT '维度代码',
    `description` TEXT COMMENT '维度描述',
    `weight` DECIMAL(5,2) NOT NULL COMMENT '权重(0-100)',
    `parent_id` INT DEFAULT 0 COMMENT '父级维度',
    `level` TINYINT DEFAULT 1 COMMENT '层级',
    `sort_order` INT DEFAULT 0 COMMENT '排序',
    `status` TINYINT DEFAULT 1 COMMENT '状态',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='评价维度表';

-- 评价指标表
CREATE TABLE `evaluation_indicator` (
    `id` INT PRIMARY KEY AUTO_INCREMENT,
    `dimension_id` INT NOT NULL COMMENT '所属维度ID',
    `name` VARCHAR(100) NOT NULL COMMENT '指标名称',
    `code` VARCHAR(30) NOT NULL COMMENT '指标代码',
    `data_type` VARCHAR(20) NOT NULL COMMENT '数据类型(number/text/enum/file)',
    `unit` VARCHAR(20) COMMENT '计量单位',
    `calculation_method` TEXT COMMENT '计算方法',
    `weight` DECIMAL(5,2) NOT NULL COMMENT '权重',
    `max_score` DECIMAL(6,2) DEFAULT 100 COMMENT '最高分值',
    `scoring_rule` TEXT COMMENT '评分规则',
    `data_source` VARCHAR(50) COMMENT '数据来源',
    `auto_calculate` TINYINT DEFAULT 0 COMMENT '是否自动计算',
    `sort_order` INT DEFAULT 0 COMMENT '排序',
    `status` TINYINT DEFAULT 1 COMMENT '状态',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (`dimension_id`) REFERENCES `evaluation_dimension`(`id`),
    UNIQUE KEY `uk_dimension_code` (`dimension_id`, `code`),
    INDEX `idx_code` (`code`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='评价指标表';

-- 评价周期表
CREATE TABLE `evaluation_period` (
    `id` INT PRIMARY KEY AUTO_INCREMENT,
    `name` VARCHAR(100) NOT NULL COMMENT '周期名称',
    `period_type` VARCHAR(20) NOT NULL COMMENT '周期类型(annual/semester/monthly)',
    `start_date` DATE NOT NULL COMMENT '开始日期',
    `end_date` DATE NOT NULL COMMENT '结束日期',
    `status` VARCHAR(20) DEFAULT 'active' COMMENT '状态(active/closed/draft)',
    `description` TEXT COMMENT '描述',
    `created_by` BIGINT COMMENT '创建人',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX `idx_dates` (`start_date`, `end_date`),
    INDEX `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='评价周期表';

-- 用户评价记录表
CREATE TABLE `user_evaluation` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `user_id` BIGINT NOT NULL COMMENT '被评价用户ID',
    `period_id` INT NOT NULL COMMENT '评价周期ID',
    `evaluator_id` BIGINT COMMENT '评价人ID',
    `evaluation_type` VARCHAR(20) DEFAULT 'regular' COMMENT '评价类型',
    `total_score` DECIMAL(8,2) DEFAULT 0 COMMENT '总分',
    `weighted_score` DECIMAL(8,2) DEFAULT 0 COMMENT '加权总分',
    `ranking` INT COMMENT '排名',
    `level` VARCHAR(20) COMMENT '等级',
    `status` VARCHAR(20) DEFAULT 'draft' COMMENT '状态(draft/submitted/reviewed/approved)',
    `submit_time` TIMESTAMP NULL COMMENT '提交时间',
    `review_time` TIMESTAMP NULL COMMENT '审核时间',
    `reviewer_id` BIGINT COMMENT '审核人ID',
    `comments` TEXT COMMENT '评价意见',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (`user_id`) REFERENCES `user`(`id`),
    FOREIGN KEY (`period_id`) REFERENCES `evaluation_period`(`id`),
    FOREIGN KEY (`evaluator_id`) REFERENCES `user`(`id`),
    FOREIGN KEY (`reviewer_id`) REFERENCES `user`(`id`),
    UNIQUE KEY `uk_user_period` (`user_id`, `period_id`),
    INDEX `idx_period` (`period_id`),
    INDEX `idx_ranking` (`ranking`),
    INDEX `idx_score` (`weighted_score`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='用户评价记录表';

-- 指标得分详情表
CREATE TABLE `indicator_score` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `evaluation_id` BIGINT NOT NULL COMMENT '评价记录ID',
    `indicator_id` INT NOT NULL COMMENT '指标ID',
    `original_value` VARCHAR(500) COMMENT '原始数值',
    `score` DECIMAL(6,2) DEFAULT 0 COMMENT '得分',
    `evidence_files` JSON COMMENT '佐证材料',
    `evaluator_comment` TEXT COMMENT '评价说明',
    `auto_calculated` TINYINT DEFAULT 0 COMMENT '是否自动计算',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    FOREIGN KEY (`evaluation_id`) REFERENCES `user_evaluation`(`id`) ON DELETE CASCADE,
    FOREIGN KEY (`indicator_id`) REFERENCES `evaluation_indicator`(`id`),
    UNIQUE KEY `uk_evaluation_indicator` (`evaluation_id`, `indicator_id`),
    INDEX `idx_indicator` (`indicator_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='指标得分详情表';

-- 业绩数据表
CREATE TABLE `performance_data` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `user_id` BIGINT NOT NULL COMMENT '用户ID',
    `data_type` VARCHAR(50) NOT NULL COMMENT '数据类型',
    `data_key` VARCHAR(100) NOT NULL COMMENT '数据键',
    `data_value` TEXT COMMENT '数据值',
    `data_date` DATE COMMENT '数据日期',
    `source` VARCHAR(50) COMMENT '数据来源',
    `status` VARCHAR(20) DEFAULT 'valid' COMMENT '状态',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (`user_id`) REFERENCES `user`(`id`),
    INDEX `idx_user_type` (`user_id`, `data_type`),
    INDEX `idx_user_date` (`user_id`, `data_date`),
    INDEX `idx_type_key` (`data_type`, `data_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='业绩数据表';

-- ===================================
-- 系统配置模块
-- ===================================

-- 系统配置表
CREATE TABLE `system_config` (
    `id` INT PRIMARY KEY AUTO_INCREMENT,
    `config_key` VARCHAR(100) NOT NULL UNIQUE COMMENT '配置键',
    `config_value` TEXT COMMENT '配置值',
    `config_type` VARCHAR(20) DEFAULT 'string' COMMENT '配置类型',
    `description` VARCHAR(200) COMMENT '配置描述',
    `group_name` VARCHAR(50) COMMENT '配置分组',
    `is_system` TINYINT DEFAULT 0 COMMENT '是否系统配置',
    `sort_order` INT DEFAULT 0 COMMENT '排序',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    `updated_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,
    INDEX `idx_group` (`group_name`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='系统配置表';

-- 操作日志表
CREATE TABLE `operation_log` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `user_id` BIGINT COMMENT '操作用户ID',
    `username` VARCHAR(50) COMMENT '用户名',
    `operation` VARCHAR(100) NOT NULL COMMENT '操作名称',
    `method` VARCHAR(50) COMMENT '请求方法',
    `request_url` VARCHAR(500) COMMENT '请求URL',
    `request_params` TEXT COMMENT '请求参数',
    `response_result` TEXT COMMENT '响应结果',
    `ip_address` VARCHAR(50) COMMENT 'IP地址',
    `user_agent` VARCHAR(500) COMMENT '用户代理',
    `execution_time` INT COMMENT '执行时间(毫秒)',
    `status` VARCHAR(20) COMMENT '操作状态(success/failure)',
    `error_msg` TEXT COMMENT '错误信息',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX `idx_user` (`user_id`),
    INDEX `idx_operation` (`operation`),
    INDEX `idx_created` (`created_at`),
    INDEX `idx_status` (`status`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='操作日志表';

-- 文件上传记录表
CREATE TABLE `file_upload` (
    `id` BIGINT PRIMARY KEY AUTO_INCREMENT,
    `file_name` VARCHAR(255) NOT NULL COMMENT '文件名',
    `original_name` VARCHAR(255) NOT NULL COMMENT '原始文件名',
    `file_path` VARCHAR(500) NOT NULL COMMENT '文件路径',
    `file_url` VARCHAR(500) COMMENT '文件URL',
    `file_size` BIGINT COMMENT '文件大小(字节)',
    `file_type` VARCHAR(50) COMMENT '文件类型',
    `mime_type` VARCHAR(100) COMMENT 'MIME类型',
    `upload_type` VARCHAR(50) COMMENT '上传类型(image/document/video)',
    `business_type` VARCHAR(50) COMMENT '业务类型',
    `business_id` BIGINT COMMENT '业务ID',
    `uploader_id` BIGINT COMMENT '上传者ID',
    `upload_ip` VARCHAR(50) COMMENT '上传IP',
    `status` VARCHAR(20) DEFAULT 'normal' COMMENT '状态',
    `created_at` TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    INDEX `idx_uploader` (`uploader_id`),
    INDEX `idx_business` (`business_type`, `business_id`),
    INDEX `idx_type` (`upload_type`),
    INDEX `idx_created` (`created_at`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4 COMMENT='文件上传记录表';

-- ===================================
-- 初始化数据
-- ===================================

-- 插入基础角色数据
INSERT INTO `role` (`name`, `code`, `description`) VALUES
('超级管理员', 'SUPER_ADMIN', '系统超级管理员，拥有所有权限'),
('管理员', 'ADMIN', '系统管理员，拥有管理权限'),
('教师', 'TEACHER', '教师角色，可发布课程和管理教学内容'),
('学生', 'STUDENT', '学生角色，可学习课程和查看内容'),
('研究员', 'RESEARCHER', '科研人员，可管理科研项目和成果'),
('访客', 'GUEST', '访客用户，只有基本查看权限');

-- 插入基础权限数据
INSERT INTO `permission` (`name`, `code`, `type`, `parent_id`, `path`, `icon`) VALUES
('系统管理', 'SYSTEM_MANAGE', 'menu', 0, '/system', 'mdi-cog'),
('用户管理', 'USER_MANAGE', 'menu', 1, '/system/user', 'mdi-account-multiple'),
('角色管理', 'ROLE_MANAGE', 'menu', 1, '/system/role', 'mdi-shield-account'),
('权限管理', 'PERMISSION_MANAGE', 'menu', 1, '/system/permission', 'mdi-key'),
('知识图谱', 'KNOWLEDGE_GRAPH', 'menu', 0, '/knowledge', 'mdi-graph'),
('方剂管理', 'FORMULA_MANAGE', 'menu', 0, '/formula', 'mdi-medical-bag'),
('教学管理', 'TEACHING_MANAGE', 'menu', 0, '/teaching', 'mdi-school'),
('科研管理', 'RESEARCH_MANAGE', 'menu', 0, '/research', 'mdi-flask'),
('业绩评价', 'EVALUATION_MANAGE', 'menu', 0, '/evaluation', 'mdi-chart-line'),
('AI助手', 'AI_ASSISTANT', 'menu', 0, '/ai-assistant', 'mdi-robot');

-- 插入课程分类数据
INSERT INTO `course_category` (`name`, `parent_id`, `icon`, `description`) VALUES
('中医基础理论', 0, 'mdi-book-open', '中医基础理论相关课程'),
('中药学', 0, 'mdi-leaf', '中药学相关课程'),
('方剂学', 0, 'mdi-medical-bag', '方剂学相关课程'),
('中医诊断学', 0, 'mdi-stethoscope', '中医诊断学相关课程'),
('中医内科学', 0, 'mdi-heart', '中医内科学相关课程'),
('中医外科学', 0, 'mdi-bandage', '中医外科学相关课程'),
('针灸推拿', 0, 'mdi-needle', '针灸推拿相关课程'),
('中医养生', 0, 'mdi-meditation', '中医养生保健相关课程');

-- 插入方剂分类数据
INSERT INTO `formula_category` (`name`, `parent_id`, `description`) VALUES
('解表剂', 0, '用于治疗表证的方剂'),
('泻下剂', 0, '用于通便泻下的方剂'),
('和解剂', 0, '用于和解表里的方剂'),
('清热剂', 0, '用于清热解毒的方剂'),
('祛暑剂', 0, '用于祛除暑邪的方剂'),
('温里剂', 0, '用于温里散寒的方剂'),
('补益剂', 0, '用于补益气血阴阳的方剂'),
('安神剂', 0, '用于安神定志的方剂'),
('开窍剂', 0, '用于开窍醒神的方剂'),
('理气剂', 0, '用于理气调气的方剂'),
('理血剂', 0, '用于理血调血的方剂'),
('治风剂', 0, '用于治疗风证的方剂'),
('治燥剂', 0, '用于治疗燥证的方剂'),
('祛湿剂', 0, '用于祛湿化湿的方剂'),
('祛痰剂', 0, '用于祛痰化痰的方剂'),
('消导剂', 0, '用于消食导滞的方剂'),
('驱虫剂', 0, '用于驱虫的方剂'),
('涌吐剂', 0, '用于涌吐的方剂'),
('收涩剂', 0, '用于收敛固涩的方剂'),
('外用剂', 0, '用于外用的方剂');

-- 插入评价维度数据
INSERT INTO `evaluation_dimension` (`name`, `code`, `description`, `weight`) VALUES
('教学工作', 'TEACHING', '教学工作相关评价', 30.00),
('科研工作', 'RESEARCH', '科研工作相关评价', 40.00),
('服务工作', 'SERVICE', '服务工作相关评价', 20.00),
('创新发展', 'INNOVATION', '创新发展相关评价', 10.00);

-- 插入评价指标数据
INSERT INTO `evaluation_indicator` (`dimension_id`, `name`, `code`, `data_type`, `unit`, `weight`, `max_score`, `auto_calculate`) VALUES
(1, '教学工作量', 'TEACHING_HOURS', 'number', '课时', 40.00, 100.00, 1),
(1, '学生评教', 'STUDENT_EVALUATION', 'number', '分', 30.00, 100.00, 1),
(1, '教学改革项目', 'TEACHING_REFORM', 'number', '项', 30.00, 100.00, 1),
(2, '发表论文', 'RESEARCH_PAPERS', 'number', '篇', 50.00, 100.00, 1),
(2, '科研项目', 'RESEARCH_PROJECTS', 'number', '项', 30.00, 100.00, 1),
(2, '科研经费', 'RESEARCH_FUNDING', 'number', '万元', 20.00, 100.00, 1),
(3, '学术兼职', 'ACADEMIC_POSITIONS', 'number', '个', 50.00, 100.00, 0),
(3, '社会服务', 'SOCIAL_SERVICE', 'number', '次', 50.00, 100.00, 0),
(4, '创新项目', 'INNOVATION_PROJECTS', 'number', '项', 60.00, 100.00, 1),
(4, '专利成果', 'PATENTS', 'number', '件', 40.00, 100.00, 1);

-- 插入系统配置数据
INSERT INTO `system_config` (`config_key`, `config_value`, `config_type`, `description`, `group_name`) VALUES
('system.name', '生物医药数字信息系统', 'string', '系统名称', 'basic'),
('system.version', '2.0.0', 'string', '系统版本', 'basic'),
('system.copyright', '© 2024 生物医药数字信息系统', 'string', '版权信息', 'basic'),
('file.upload.max.size', '100', 'number', '文件上传最大大小(MB)', 'upload'),
('file.upload.allowed.types', 'jpg,jpeg,png,gif,pdf,doc,docx,xls,xlsx,ppt,pptx,zip,rar,mp4,avi', 'string', '允许上传的文件类型', 'upload'),
('ai.model.provider', 'openai', 'string', 'AI模型提供商', 'ai'),
('ai.model.name', 'gpt-3.5-turbo', 'string', 'AI模型名称', 'ai'),
('evaluation.auto.calculate', 'true', 'boolean', '是否开启自动评价', 'evaluation'),
('evaluation.period.default.type', 'annual', 'string', '默认评价周期类型', 'evaluation');

SET FOREIGN_KEY_CHECKS = 1;

-- ===================================
-- 数据库索引优化建议
-- ===================================

-- 为高频查询字段添加复合索引
CREATE INDEX `idx_herb_location_geo` ON `herb_location` (`longitude`, `latitude`, `province`);
CREATE INDEX `idx_formula_efficacy_safety` ON `formula` (`efficacy_rating`, `safety_level`, `status`);
CREATE INDEX `idx_course_rating_student` ON `course` (`rating`, `student_count`, `status`);
CREATE INDEX `idx_research_date_type` ON `research_achievement` (`publish_date`, `achievement_type`);
CREATE INDEX `idx_evaluation_period_score` ON `user_evaluation` (`period_id`, `weighted_score`, `ranking`);

-- 为全文搜索添加索引
ALTER TABLE `herb` ADD FULLTEXT `ft_herb_search` (`name`, `alias`, `effect`, `description`);
ALTER TABLE `formula` ADD FULLTEXT `ft_formula_search` (`name`, `alias`, `function_effect`, `main_treatment`);
ALTER TABLE `course` ADD FULLTEXT `ft_course_search` (`title`, `introduction`, `tags`);

-- ===================================
-- 数据库视图创建
-- ===================================

-- 用户完整信息视图
CREATE VIEW `v_user_info` AS
SELECT 
    u.id,
    u.username,
    u.email,
    u.phone,
    u.real_name,
    u.avatar_url,
    u.status,
    u.last_login_time,
    u.created_at,
    GROUP_CONCAT(r.name) AS roles,
    GROUP_CONCAT(r.code) AS role_codes
FROM `user` u
LEFT JOIN `user_role` ur ON u.id = ur.user_id
LEFT JOIN `role` r ON ur.role_id = r.id
WHERE u.status = 1
GROUP BY u.id;

-- 课程统计视图
CREATE VIEW `v_course_statistics` AS
SELECT 
    c.id,
    c.title,
    c.teacher_id,
    u.real_name AS teacher_name,
    c.category_id,
    cc.name AS category_name,
    c.status,
    c.view_count,
    c.student_count,
    c.rating,
    c.rating_count,
    COUNT(cl.id) AS lesson_count,
    SUM(cl.duration) AS total_duration,
    c.created_at
FROM `course` c
LEFT JOIN `user` u ON c.teacher_id = u.id
LEFT JOIN `course_category` cc ON c.category_id = cc.id
LEFT JOIN `course_lesson` cl ON c.id = cl.course_id
GROUP BY c.id;

-- 方剂详细信息视图
CREATE VIEW `v_formula_detail` AS
SELECT 
    f.id,
    f.name,
    f.alias,
    f.source,
    f.author,
    fc.name AS category_name,
    f.function_effect,
    f.main_treatment,
    f.usage_frequency,
    f.efficacy_rating,
    f.safety_level,
    COUNT(fh.id) AS herb_count,
    GROUP_CONCAT(CONCAT(fh.herb_name, '(', fh.dosage, fh.unit, ')') SEPARATOR '、') AS composition_detail
FROM `formula` f
LEFT JOIN `formula_category` fc ON f.category_id = fc.id
LEFT JOIN `formula_herb` fh ON f.id = fh.formula_id
WHERE f.status = 1
GROUP BY f.id;

-- 用户学习统计视图
CREATE VIEW `v_user_study_stats` AS
SELECT 
    sr.user_id,
    u.real_name AS user_name,
    COUNT(DISTINCT sr.course_id) AS enrolled_courses,
    COUNT(DISTINCT CASE WHEN sr.progress >= 100 THEN sr.course_id END) AS completed_courses,
    SUM(sr.study_duration) AS total_study_time,
    AVG(sr.progress) AS avg_progress
FROM `study_record` sr
LEFT JOIN `user` u ON sr.user_id = u.id
GROUP BY sr.user_id;

-- 科研成果统计视图
CREATE VIEW `v_research_stats` AS
SELECT 
    ra.first_author_id AS user_id,
    u.real_name AS user_name,
    COUNT(*) AS total_achievements,
    COUNT(CASE WHEN ra.achievement_type = 'paper' THEN 1 END) AS paper_count,
    COUNT(CASE WHEN ra.achievement_type = 'patent' THEN 1 END) AS patent_count,
    COUNT(CASE WHEN ra.achievement_type = 'award' THEN 1 END) AS award_count,
    AVG(ra.impact_factor) AS avg_impact_factor,
    SUM(ra.citation_count) AS total_citations
FROM `research_achievement` ra
LEFT JOIN `user` u ON ra.first_author_id = u.id
WHERE ra.status = 'published'
GROUP BY ra.first_author_id;

-- ===================================
-- 数据库函数和存储过程
-- ===================================

DELIMITER //

-- 计算两点间距离的函数
CREATE FUNCTION `calculate_distance`(
    lat1 DECIMAL(10,7),
    lng1 DECIMAL(10,7),
    lat2 DECIMAL(10,7),
    lng2 DECIMAL(10,7)
) RETURNS DECIMAL(10,3)
READS SQL DATA
DETERMINISTIC
BEGIN
    DECLARE distance DECIMAL(10,3);
    SET distance = 6371 * 2 * ASIN(SQRT(
        POWER(SIN((lat2 - lat1) * PI() / 180 / 2), 2) +
        COS(lat1 * PI() / 180) * COS(lat2 * PI() / 180) *
        POWER(SIN((lng2 - lng1) * PI() / 180 / 2), 2)
    ));
    RETURN distance;
END //

-- 更新课程统计信息的存储过程
CREATE PROCEDURE `update_course_statistics`(IN course_id BIGINT)
BEGIN
    DECLARE lesson_count INT DEFAULT 0;
    DECLARE total_duration INT DEFAULT 0;
    DECLARE student_count INT DEFAULT 0;
    DECLARE view_count INT DEFAULT 0;
    
    -- 统计课时数和总时长
    SELECT COUNT(*), IFNULL(SUM(duration), 0)
    INTO lesson_count, total_duration
    FROM course_lesson
    WHERE course_id = course_id AND status = 'published';
    
    -- 统计学生数
    SELECT COUNT(DISTINCT user_id)
    INTO student_count
    FROM study_record
    WHERE course_id = course_id;
    
    -- 统计观看次数
    SELECT SUM(view_count)
    INTO view_count
    FROM course_lesson
    WHERE course_id = course_id;
    
    -- 更新课程表
    UPDATE course
    SET 
        student_count = student_count,
        view_count = view_count,
        duration = total_duration,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = course_id;
    
END //

-- 自动计算用户评价得分的存储过程
CREATE PROCEDURE `calculate_user_evaluation_score`(
    IN eval_id BIGINT
)
BEGIN
    DECLARE total_score DECIMAL(8,2) DEFAULT 0;
    DECLARE weighted_score DECIMAL(8,2) DEFAULT 0;
    DECLARE total_weight DECIMAL(5,2) DEFAULT 0;
    
    -- 计算加权总分
    SELECT 
        SUM(eis.score * ei.weight / 100),
        SUM(ei.weight)
    INTO weighted_score, total_weight
    FROM indicator_score eis
    JOIN evaluation_indicator ei ON eis.indicator_id = ei.id
    WHERE eis.evaluation_id = eval_id;
    
    -- 计算标准化得分
    IF total_weight > 0 THEN
        SET total_score = weighted_score / total_weight * 100;
    END IF;
    
    -- 更新评价记录
    UPDATE user_evaluation
    SET 
        total_score = total_score,
        weighted_score = weighted_score,
        level = CASE 
            WHEN weighted_score >= 95 THEN '优秀'
            WHEN weighted_score >= 85 THEN '良好'
            WHEN weighted_score >= 75 THEN '中等'
            WHEN weighted_score >= 60 THEN '及格'
            ELSE '不及格'
        END,
        updated_at = CURRENT_TIMESTAMP
    WHERE id = eval_id;
    
END //

DELIMITER ;

-- ===================================
-- 数据库触发器
-- ===================================

DELIMITER //

-- 用户登录时间更新触发器
CREATE TRIGGER `tr_user_last_login`
AFTER UPDATE ON `user`
FOR EACH ROW
BEGIN
    IF NEW.last_login_time != OLD.last_login_time THEN
        INSERT INTO operation_log (
            user_id, username, operation, ip_address, created_at
        ) VALUES (
            NEW.id, NEW.username, 'USER_LOGIN', 'system', NOW()
        );
    END IF;
END //

-- 学习记录更新时自动更新课程统计
CREATE TRIGGER `tr_study_record_update`
AFTER INSERT ON `study_record`
FOR EACH ROW
BEGIN
    CALL update_course_statistics(NEW.course_id);
END //

-- 评价指标得分更新时自动计算总分
CREATE TRIGGER `tr_indicator_score_update`
AFTER INSERT ON `indicator_score`
FOR EACH ROW
BEGIN
    CALL calculate_user_evaluation_score(NEW.evaluation_id);
END //

CREATE TRIGGER `tr_indicator_score_update_after_update`
AFTER UPDATE ON `indicator_score`
FOR EACH ROW
BEGIN
    CALL calculate_user_evaluation_score(NEW.evaluation_id);
END //

DELIMITER ;
```

### 4.2 Neo4j图数据库设计

```cypher
// ===================================
// 中医药知识图谱 - Neo4j数据库设计
// ===================================

// 清理现有数据（开发环境）
MATCH (n) DETACH DELETE n;

// 创建约束和索引
CREATE CONSTRAINT herb_name_unique IF NOT EXISTS FOR (h:Herb) REQUIRE h.name IS UNIQUE;
CREATE CONSTRAINT formula_name_unique IF NOT EXISTS FOR (f:Formula) REQUIRE f.name IS UNIQUE;
CREATE CONSTRAINT disease_name_unique IF NOT EXISTS FOR (d:Disease) REQUIRE d.name IS UNIQUE;
CREATE CONSTRAINT syndrome_name_unique IF NOT EXISTS FOR (s:Syndrome) REQUIRE s.name IS UNIQUE;
CREATE CONSTRAINT symptom_name_unique IF NOT EXISTS FOR (sy:Symptom) REQUIRE sy.name IS UNIQUE;

// 创建全文搜索索引
CREATE FULLTEXT INDEX herb_search_index IF NOT EXISTS 
FOR (h:Herb) ON EACH [h.name, h.alias, h.pinyin, h.effect];

CREATE FULLTEXT INDEX formula_search_index IF NOT EXISTS 
FOR (f:Formula) ON EACH [f.name, f.alias, f.function, f.indication];

CREATE FULLTEXT INDEX disease_search_index IF NOT EXISTS 
FOR (d:Disease) ON EACH [d.name, d.symptoms, d.pathogenesis];

// ===================================
// 节点创建示例
// ===================================

// 创建药材节点
CREATE (川芎:Herb {
    id: 1,
    name: '川芎',
    pinyin: 'chuanxiong',
    alias: ['芎藭', '香果', '胡芎', '马衔芎藭'],
    scientific_name: 'Ligusticum chuanxiong Hort.',
    family: '伞形科',
    nature: '辛，温',
    meridian: ['肝经', '胆经', '心包经'],
    effect: '活血行气，祛风止痛',
    function_detail: [
        '活血祛瘀：用于血瘀气滞，胸痹心痛',
        '行气止痛：用于气滞血瘀，头痛胁痛',
        '祛风止痛：用于风湿痹痛，头风头痛'
    ],
    usage: '3-10g',
    contraindication: '阴虚火旺，上盛下虚及气弱者慎用',
    origin: ['四川', '云南', '贵州', '广西'],
    quality_standard: '以个大、质坚实、断面色白、香气浓者为佳',
    created_at: datetime(),
    updated_at: datetime()
});

CREATE (当归:Herb {
    id: 2,
    name: '当归',
    pinyin: 'danggui',
    alias: ['秦哪', '云归', '西当归', '岷当归'],
    scientific_name: 'Angelica sinensis (Oliv.) Diels',
    family: '伞形科',
    nature: '甘、辛，温',
    meridian: ['肝经', '心经', '脾经'],
    effect: '补血活血，调经止痛，润肠通便',
    function_detail: [
        '补血：用于血虚萎黄，眩晕心悸',
        '活血：用于瘀血阻滞，痛经经闭',
        '调经：用于月经不调，崩漏下血',
        '润肠：用于血虚便秘'
    ],
    usage: '6-12g',
    contraindication: '湿盛中满及大便溏泄者慎用',
    origin: ['甘肃', '云南', '四川', '陕西'],
    quality_standard: '以身长、支大、油润、断面黄白色者为佳'
});

CREATE (桃仁:Herb {
    id: 3,
    name: '桃仁',
    pinyin: 'taoren',
    alias: ['桃核仁', '毛桃仁'],
    scientific_name: 'Prunus persica (L.) Batsch',
    family: '蔷薇科',
    nature: '苦、甘，平；有小毒',
    meridian: ['心经', '肝经', '大肠经'],
    effect: '活血祛瘀，润肠通便',
    usage: '4.5-9g',
    contraindication: '孕妇忌用',
    origin: ['山东', '河北', '河南', '山西'],
    toxicity: '含氢氰酸，过量可致中毒'
});

// 创建方剂节点
CREATE (血府逐瘀汤:Formula {
    id: 1,
    name: '血府逐瘀汤',
    alias: ['血府逐瘀汤'],
    source: '医林改错',
    author: '王清任',
    dynasty: '清代',
    category: '理血剂-活血化瘀',
    composition: '桃仁12g，红花9g，当归9g，生地黄9g，川芎4.5g，赤芍6g，牛膝9g，桔梗4.5g，柴胡3g，枳壳6g，甘草3g',
    preparation: '水煎服',
    function: '活血祛瘀，行气止痛',
    indication: '胸中血瘀，血行不畅，胸痛，头痛日久不愈',
    symptom_analysis: '胸痛，头痛，痛如针刺而有定处，或呃逆日久不止，或内热瞀闷，或心悸怔忡，或失眠多梦，或急躁易怒，或入暮潮热，或唇暗舌质紫暗或有瘀斑，脉涩或弦紧',
    pathogenesis: '瘀血内阻，血行不畅，不通则痛',
    treatment_principle: '活血祛瘀，行气止痛',
    formula_analysis: '方中桃仁、红花活血祛瘀为君药；当归、川芎、赤芍、生地黄养血活血为臣药；牛膝活血通经，引血下行，桔梗开胸行气，柴胡疏肝解郁，枳壳理气宽胸为佐药；甘草调和诸药为使药',
    modern_application: ['冠心病心绞痛', '脑血管病', '神经性头痛', '胸部挫伤'],
    clinical_experience: '用于各种瘀血证，效果显著',
    usage_frequency: 850,
    efficacy_rating: 4.6,
    safety_level: 4,
    evidence_level: 'B级'
});

// 创建疾病节点
CREATE (血瘀头痛:Disease {
    id: 1,
    name: '血瘀头痛',
    category: '头痛',
    symptoms: ['头痛如刺', '痛有定处', '舌质紫暗', '脉涩'],
    pathogenesis: '瘀血阻络，不通则痛',
    syndrome_differentiation: '头痛如刺，痛有定处，舌质紫暗或有瘀斑，脉涩',
    treatment_principle: '活血化瘀，通络止痛',
    prognosis: '一般良好，需长期调理'
});

CREATE (胸痹心痛:Disease {
    id: 2,
    name: '胸痹心痛',
    category: '胸痹',
    symptoms: ['胸部闷痛', '心前区刺痛', '舌质紫暗', '脉涩或结代'],
    pathogenesis: '心脉瘀阻，血行不畅',
    syndrome_differentiation: '胸部闷痛，心前区刺痛，痛有定处，舌质紫暗，脉涩',
    treatment_principle: '活血化瘀，通脉止痛',
    modern_diagnosis: ['冠心病', '心绞痛', '心肌梗死']
});

// 创建症状节点
CREATE (头痛如刺:Symptom {
    id: 1,
    name: '头痛如刺',
    description: '头部疼痛，如针刺样，痛有定处',
    location: '头部',
    nature: '刺痛',
    characteristics: ['痛有定处', '如针刺样', '持续性']
});

CREATE (胸痛:Symptom {
    id: 2,
    name: '胸痛',
    description: '胸部疼痛不适',
    location: '胸部',
    nature: '胀痛或刺痛',
    characteristics: ['胸部闷胀', '或有刺痛', '活动后加重']
});

// ===================================
// 关系创建示例
// ===================================

// 方剂组成关系
MATCH (f:Formula {name: '血府逐瘀汤'}), (h:Herb {name: '川芎'})
CREATE (f)-[:CONTAINS {
    dosage: '4.5g',
    role: '臣药',
    function: '活血行气',
    processing: '生用',
    sort_order: 5
}]->(h);

MATCH (f:Formula {name: '血府逐瘀汤'}), (h:Herb {name: '当归'})
CREATE (f)-[:CONTAINS {
    dosage: '9g',
    role: '臣药',
    function: '补血活血',
    processing: '生用',
    sort_order: 3
}]->(h);

MATCH (f:Formula {name: '血府逐瘀汤'}), (h:Herb {name: '桃仁'})
CREATE (f)-[:CONTAINS {
    dosage: '12g',
    role: '君药',
    function: '活血祛瘀',
    processing: '去皮尖',
    sort_order: 1
}]->(h);

// 治疗关系
MATCH (f:Formula {name: '血府逐瘀汤'}), (d:Disease {name: '血瘀头痛'})
CREATE (f)-[:TREATS {
    efficacy: '显著',
    evidence_level: 'A',
    clinical_data: '临床有效率85%',
    usage_note: '水煎服，日1剂，分2次服'
}]->(d);

MATCH (f:Formula {name: '血府逐瘀汤'}), (d:Disease {name: '胸痹心痛'})
CREATE (f)-[:TREATS {
    efficacy: '良好',
    evidence_level: 'A',
    clinical_data: '临床有效率78%',
    usage_note: '水煎服，日1剂，分2次服'
}]->(d);

// 药材治疗关系
MATCH (h:Herb {name: '川芎'}), (d:Disease {name: '血瘀头痛'})
CREATE (h)-[:TREATS {
    mechanism: '活血行气，祛风止痛',
    primary_active_compounds: ['川芎嗪', '阿魏酸', '川芎内酯'],
    pharmacological_action: '扩张血管，改善微循环'
}]->(d);

// 疾病症状关系
MATCH (d:Disease {name: '血瘀头痛'}), (s:Symptom {name: '头痛如刺'})
CREATE (d)-[:HAS_SYMPTOM {
    frequency: '必见',
    severity: '重',
    description: '主要症状'
}]->(s);

// 药材功效归经关系
CREATE (肝经:Meridian {
    name: '肝经',
    full_name: '足厥阴肝经',
    function: '疏泄气机，调畅情志'
});

MATCH (h:Herb {name: '川芎'}), (m:Meridian {name: '肝经'})
CREATE (h)-[:ENTERS_MERIDIAN {
    primary: true,
    function: '疏肝行气'
}]->(m);

// 药物相互作用关系
MATCH (h1:Herb {name: '川芎'}), (h2:Herb {name: '当归'})
CREATE (h1)-[:SYNERGISTIC_WITH {
    effect: '增强活血功效',
    mechanism: '当归补血，川芎行血，补中有行，行中有补',
    ratio: '1:2',
    compatibility_grade: 'A'
}]->(h2);

// 药材禁忌关系
CREATE (阴虚火旺:Syndrome {
    name: '阴虚火旺',
    symptoms: ['五心烦热', '盗汗', '口干咽燥', '舌红少苔'],
    pathogenesis: '阴液亏虚，虚火上炎'
});

MATCH (h:Herb {name: '川芎'}), (s:Syndrome {name: '阴虚火旺'})
CREATE (h)-[:CONTRAINDICATED_IN {
    reason: '川芎辛温，易耗阴助火',
    severity: '慎用',
    alternative: '可用生地、玄参等滋阴药'
}]->(s);

// ===================================
// 复杂查询示例
// ===================================

// 查询治疗头痛的所有方剂及其组成
MATCH (f:Formula)-[t:TREATS]->(d:Disease)
WHERE d.name CONTAINS '头痛'
OPTIONAL MATCH (f)-[c:CONTAINS]->(h:Herb)
RETURN f.name AS 方剂名称, 
       f.function AS 功效, 
       t.efficacy AS 疗效,
       collect({
           药材: h.name, 
           用量: c.dosage, 
           作用: c.role
       }) AS 组成
ORDER BY t.efficacy DESC;

// 查询川芎的所有配伍药物及配伍效果
MATCH (川芎:Herb {name: '川芎'})-[r:SYNERGISTIC_WITH|ANTAGONISTIC_WITH]-(other:Herb)
RETURN 川芎.name AS 主药,
       type(r) AS 关系类型,
       other.name AS 配伍药物,
       r.effect AS 配伍效果,
       r.mechanism AS 配伍机理;

// 查询血府逐瘀汤的完整信息
MATCH (f:Formula {name: '血府逐瘀汤'})
OPTIONAL MATCH (f)-[c:CONTAINS]->(h:Herb)
OPTIONAL MATCH (f)-[t:TREATS]->(d:Disease)
OPTIONAL MATCH (d)-[hs:HAS_SYMPTOM]->(s:Symptom)
RETURN f AS 方剂信息,
       collect(DISTINCT {
           药材: h.name,
           用量: c.dosage,
           作用: c.role,
           功能: c.function
       }) AS 药物组成,
       collect(DISTINCT {
           疾病: d.name,
           疗效: t.efficacy,
           症状: collect(s.name)
       }) AS 主治疾病;

// 查询某症状的所有治疗方案
MATCH (s:Symptom {name: '头痛如刺'})
MATCH (d:Disease)-[:HAS_SYMPTOM]->(s)
MATCH (f:Formula)-[:TREATS]->(d)
OPTIONAL MATCH (h:Herb)-[:TREATS]->(d)
RETURN s.name AS 症状,
       collect(DISTINCT d.name) AS 相关疾病,
       collect(DISTINCT f.name) AS 治疗方剂,
       collect(DISTINCT h.name) AS 治疗药材;

// 查找药物配伍禁忌
MATCH (h1:Herb)-[r:ANTAGONISTIC_WITH|CONTRAINDICATED_WITH]-(h2:Herb)
RETURN h1.name AS 药物1,
       h2.name AS 药物2,
       type(r) AS 禁忌类型,
       r.reason AS 禁忌原因,
       r.severity AS 严重程度;

// 分析方剂组方规律
MATCH (f:Formula)-[:CONTAINS]->(h:Herb)
WHERE f.category CONTAINS '活血'
WITH h, count(f) AS 使用频次, collect(f.name) AS 方剂列表
WHERE 使用频次 >= 3
RETURN h.name AS 药材名称,
       h.effect AS 功效,
       使用频次,
       方剂列表
ORDER BY 使用频次 DESC;

// 构建药材相似性网络
MATCH (h1:Herb)-[:CONTAINS*2]-(h2:Herb)
WHERE h1 <> h2
WITH h1, h2, count(*) AS 共现次数
WHERE 共现次数 >= 2
RETURN h1.name AS 药材1,
       h2.name AS 药材2,
       共现次数
ORDER BY 共现次数 DESC;

// ===================================
// 数据导入Cypher语句
// ===================================

// 批量导入药材数据
LOAD CSV WITH HEADERS FROM 'file:///herbs.csv' AS row
CREATE (h:Herb {
    id: toInteger(row.id),
    name: row.name,
    pinyin: row.pinyin,
    alias: split(row.alias, '|'),
    scientific_name: row.scientific_name,
    family: row.family,
    nature: row.nature,
    meridian: split(row.meridian, '|'),
    effect: row.effect,
    usage: row.usage,
    contraindication: row.contraindication,
    origin: split(row.origin, '|')
});

// 批量导入方剂数据
LOAD CSV WITH HEADERS FROM 'file:///formulas.csv' AS row
CREATE (f:Formula {
    id: toInteger(row.id),
    name: row.name,
    source: row.source,
    author: row.author,
    dynasty: row.dynasty,
    category: row.category,
    composition: row.composition,
    function: row.function,
    indication: row.indication,
    usage_frequency: toInteger(row.usage_frequency),
    efficacy_rating: toFloat(row.efficacy_rating)
});

// 批量创建方剂-药材关系
LOAD CSV WITH HEADERS FROM 'file:///formula_herbs.csv' AS row
MATCH (f:Formula {id: toInteger(row.formula_id)})
MATCH (h:Herb {id: toInteger(row.herb_id)})
CREATE (f)-[:CONTAINS {
    dosage: row.dosage,
    role: row.role,
    function: row.function,
    sort_order: toInteger(row.sort_order)
}]->(h);

// ===================================
// 图算法应用示例
// ===================================

// 使用PageRank算法找出重要药材
CALL gds.pageRank.stream('herbs-formulas-graph')
YIELD nodeId, score
MATCH (h:Herb) WHERE id(h) = nodeId
RETURN h.name AS 药材名称, h.effect AS 功效, score AS 重要性得分
ORDER BY score DESC
LIMIT 20;

// 使用社区检测算法找出药材功效群组
CALL gds.louvain.stream('herbs-similarity-graph')
YIELD nodeId, communityId
MATCH (h:Herb) WHERE id(h) = nodeId
WITH communityId, collect(h.name) AS 药材群组, collect(h.effect) AS 功效列表
RETURN communityId AS 群组ID, 药材群组, 功效列表
ORDER BY size(药材群组) DESC;

// 使用最短路径算法找出治疗路径
MATCH path = shortestPath((start:Symptom {name: '头痛如刺'})-[*]-(end:Formula))
RETURN path
LIMIT 5;
```

------

## 五、项目验收标准

### 5.1 功能验收清单

**✓ 核心功能模块**

1. [ ] 中医药知识图谱：支持药材、方剂、疾病关系查询和可视化
2. [ ] 方剂管理系统：完整的方剂CRUD、智能推荐、配伍分析
3. [ ] AI科研助手：智能问答、文献检索、研究方案生成
4. [ ] 在线教学平台：视频播放、进度跟踪、笔记功能
5. [ ] 业绩评价体系：自动计算、多维度评价、排名统计

**✓ 技术指标**

1. [ ] 主页加载时间 P95 < 800ms
2. [ ] 知识图谱查询响应时间 < 1.5s
3. [ ] 支持1000+并发用户
4. [ ] 数据库支持10万+条记录
5. [ ] 移动端兼容性良好

**✓ 数据要求**

1. [ ] 重庆地区药材分布数据 300+ 条
2. [ ] 经典方剂数据 ≥ 3000 条
3. [ ] 评价维度 ≥ 6 个
4. [ ] 知识图谱节点 ≥ 5000 个
5. [ ] 关系连接 ≥ 10000 条

**✓ 用户体验**

1. [ ] 统一的Material Design 3风格界面
2. [ ] 响应式布局适配多端设备
3. [ ] 流畅的页面切换和交互动效
4. [ ] 完善的错误处理和用户提示
5. [ ] 无障碍访问支持

**✓ 文档交付**

1. [ ] 系统架构图和ER图
2. [ ] API接口文档（Swagger）
3. [ ] 部署脚本和环境配置
4. [ ] 用户操作手册
5. [ ] 演示PPT和视频

### 5.2 技术债务控制

- **代码质量**：保持80%以上的测试覆盖率
- **性能优化**：关键接口响应时间控制在合理范围
- **安全防护**：SQL注入、XSS攻击防护
- **监控告警**：系统运行状态实时监控
- **扩展性**：支持水平扩展和功能模块热插拔

------

## 六、风险评估与应对

### 6.1 技术风险

**高风险项**：

- **Neo4j学习曲线**：图数据库相对复杂，Cypher语法需要快速掌握
  - *应对*：提前准备Neo4j教程，重点学习基础CRUD和关系查询
  - *备选*：如学习困难，可先用MySQL存储图数据，后期迁移
- **AI API集成**：大语言模型API调用可能不稳定或配额限制
  - *应对*：准备多个API提供商(OpenAI/Azure/本地模型)作为备选
  - *备选*：使用预设问答库模拟AI功能进行演示

**中风险项**：

- 多端协同开发

  ：Web、移动端、桌面端同时开发时间紧张

  - *应对*：优先保证Web端功能完整，移动端和桌面端采用渐进式开发

- 大数据量处理

  ：知识图谱数据量大，可能影响查询性能

  - *应对*：合理设计索引，使用分页查询，关键查询添加缓存

### 6.2 进度风险

**关键路径**：知识图谱构建 → AI助手集成 → 前端可视化

- *缓解措施*：并行开发，提前准备测试数据
- *应急预案*：如进度紧张，先完成核心功能演示版本

### 6.3 质量风险

**数据质量**：中医药数据准确性和完整性要求高

- *应对*：使用权威数据源(中国药典、经典医籍)，设置数据校验机制

**系统稳定性**：多模块集成可能引入系统不稳定因素

- *应对*：充分测试，设置监控告警，准备回滚方案

------

## 七、团队协作与分工建议

### 7.1 推荐分工策略

**主线开发（核心功能）**：

- **知识图谱模块**：需要对中医药知识有一定了解的同学负责
- **AI科研助手**：熟悉NLP和API调用的同学
- **方剂管理系统**：擅长复杂业务逻辑开发的同学
- **在线教学平台**：熟悉音视频处理的同学
- **业绩评价体系**：数学建模能力强的同学

**副线开发（支撑功能）**：

- **前端UI统一**：设计能力强的同学负责整体界面规范
- **移动端适配**：Flutter开发经验的同学
- **系统部署运维**：熟悉Linux和Docker的同学
- **测试与文档**：细心负责的同学

### 7.2 协作工具推荐

**代码管理**：

```bash
# Git分支策略
main分支：稳定版本
develop分支：开发主分支
feature/知识图谱：功能分支
feature/AI助手：功能分支
hotfix/紧急修复：修复分支
```

**项目管理**：

- 使用GitHub Issues跟踪任务和Bug
- 每日站会同步进度和问题
- 使用看板管理任务状态

**文档协作**：

- 统一使用Markdown格式
- API文档使用Swagger自动生成
- 使用draw.io绘制架构图

------

## 八、学习资源推荐

### 8.1 图数据库学习路径

**Neo4j基础教程**：

```cypher
// 1. 基础语法练习
CREATE (n:Person {name: '张三', age: 25})
MATCH (n:Person) WHERE n.name = '张三' RETURN n

// 2. 关系操作
MATCH (a:Person), (b:Person) 
WHERE a.name = '张三' AND b.name = '李四'
CREATE (a)-[:KNOWS]->(b)

// 3. 复杂查询
MATCH (p:Person)-[:KNOWS*2]-(friend)
WHERE p.name = '张三'
RETURN friend.name
```

**推荐学习资源**：

- [Neo4j官方教程](https://neo4j.com/developer/get-started/)
- [Cypher查询语言指南](https://neo4j.com/developer/cypher/)
- [图数据库实战案例](https://neo4j.com/use-cases/)

### 8.2 Vue3生态学习

**核心概念掌握**：

```javascript
// 1. Composition API
import { ref, computed, onMounted } from 'vue'

export default {
  setup() {
    const count = ref(0)
    const doubleCount = computed(() => count.value * 2)
    
    onMounted(() => {
      console.log('组件已挂载')
    })
    
    return { count, doubleCount }
  }
}

// 2. Pinia状态管理
import { defineStore } from 'pinia'

export const useUserStore = defineStore('user', {
  state: () => ({
    name: '',
    avatar: ''
  }),
  actions: {
    updateUserInfo(info) {
      this.name = info.name
      this.avatar = info.avatar
    }
  }
})
```

### 8.3 数据可视化学习

**D3.js图网络**：

```javascript
// 基础网络图绘制
const simulation = d3.forceSimulation(nodes)
  .force('link', d3.forceLink(links).id(d => d.id))
  .force('charge', d3.forceManyBody().strength(-300))
  .force('center', d3.forceCenter(width / 2, height / 2))

// 节点绘制
const node = svg.append('g')
  .selectAll('circle')
  .data(nodes)
  .enter().append('circle')
  .attr('r', 5)
  .attr('fill', d => colorScale(d.group))
```

**ECharts配置**：

```javascript
// 关系图配置
option = {
  series: [{
    type: 'graph',
    layout: 'force',
    data: nodes,
    links: links,
    categories: categories,
    roam: true,
    label: {
      show: true,
      position: 'right'
    },
    force: {
      repulsion: 100,
      gravity: 0.02,
      edgeLength: 150
    }
  }]
}
```

------

## 九、扩展功能规划

### 9.1 短期扩展（1个月内）

**移动端APP优化**：

- 增加离线缓存功能
- 支持语音搜索
- 添加夜间模式
- 集成推送通知

**AI功能增强**：

- 多轮对话记忆
- 个性化推荐算法
- 语音问答支持
- 图片识别药材

### 9.2 中期扩展（3个月内）

**社交化功能**：

- 用户讨论社区
- 专家在线答疑
- 学习小组功能
- 知识分享奖励

**高级分析功能**：

- 处方安全性检查
- 用药禁忌自动提醒
- 个体化用药建议
- 疗效预测模型

### 9.3 长期扩展（6个月+）

**产业化应用**：

- 医院HIS系统对接
- 药企研发数据支持
- 监管部门数据报送
- 国际化多语言支持

**前沿技术集成**：

- VR/AR中药材识别
- 区块链药材溯源
- 物联网设备接入
- 5G实时远程诊疗

------

## 十、项目总结与展望

### 10.1 核心价值总结

本项目二阶段在原有中药材地理信息系统基础上，通过引入**知识图谱、AI科研助手、方剂管理、教学科研一体化、业绩评价**等核心模块，实现了从单一功能向综合性中医药数字信息平台的跨越。

**技术创新亮点**：

1. **知识图谱驱动**：构建了结构化的中医药知识体系，实现知识的关联推理
2. **AI深度集成**：不是简单的聊天机器人，而是结合业务场景的专业AI助手
3. **多模态数据融合**：地理信息、文献资料、教学视频、评价数据的有机统一
4. **跨端协同设计**：Web、移动端、桌面端统一的用户体验

**业务价值体现**：

1. **教育教学**：从传统的课件展示升级为互动式智能教学平台
2. **科学研究**：提供从文献检索到研究方案生成的全流程AI支持
3. **临床应用**：通过方剂推荐和配伍分析辅助临床决策
4. **管理评价**：建立科学的业绩评价体系，促进人才发展

### 10.2 技术可行性分析

**已验证技术**：SpringBoot、Vue3、MySQL等均为成熟稳定的技术栈 **新技术应用**：Neo4j图数据库和AI大模型API均有完善的开发文档和社区支持 **风险可控**：关键技术点都有备选方案，确保项目能够如期交付

### 10.3 实用性与可持续性

**immediate实用性**：

- 教师可用于课程制作和教学管理
- 学生可用于在线学习和知识查询
- 研究人员可用于文献检索和数据分析
- 管理人员可用于业绩评价和统计分析

**可持续发展**：

- 模块化架构支持功能扩展
- 标准化API接口便于第三方集成
- 丰富的数据积累为后续AI训练提供基础
- 开放的技术栈降低维护门槛

### 10.4 预期成果

**功能成果**：

- 完整的中医药数字信息平台
- 5个核心功能模块全部可演示
- 三端(Web/移动/桌面)协同的用户体验
- 智能化的AI助手功能

**数据成果**：

- 中医药知识图谱(5000+节点)
- 方剂数据库(3000+方剂)
- 重庆药材分布数据(300+地点)
- 完整的评价指标体系

**技术成果**：

- 现代化的微服务架构
- 图数据库应用实践
- AI与业务深度融合
- 跨端开发技术栈

**社会价值**：

- 推动中医药知识数字化传承
- 提升中医药教学科研效率
- 为中医药现代化发展提供技术支撑
- 培养复合型中医药信息化人才

------

## 附录：关键代码示例

### A1. 项目启动配置

**后端启动配置（application.yml）**：

```yaml
spring:
  application:
    name: tcm-digital-platform
  
  # 数据源配置
  datasource:
    url: jdbc:mysql://localhost:3306/tcm_platform?useUnicode=true&characterEncoding=utf8&serverTimezone=Asia/Shanghai
    username: root
    password: your_password
    driver-class-name: com.mysql.cj.jdbc.Driver
    
  # Neo4j配置
  neo4j:
    uri: bolt://localhost:7687
    authentication:
      username: neo4j
      password: your_neo4j_password
      
  # Redis配置
  redis:
    host: localhost
    port: 6379
    password: your_redis_password
    database: 0
    
  # 文件上传配置
  servlet:
    multipart:
      max-file-size: 100MB
      max-request-size: 100MB

# MyBatis Plus配置
mybatis-plus:
  configuration:
    map-underscore-to-camel-case: true
    log-impl: org.apache.ibatis.logging.stdout.StdOutImpl
  global-config:
    db-config:
      id-type: auto
      logic-delete-value: 1
      logic-not-delete-value: 0

# 自定义配置
tcm:
  ai:
    provider: openai
    api-key: your_openai_api_key
    model: gpt-3.5-turbo
  oss:
    endpoint: your_oss_endpoint
    access-key: your_access_key
    secret-key: your_secret_key
    bucket: tcm-platform
```

**前端环境配置（.env.development）**：

```env
# API地址
VITE_API_BASE_URL=http://localhost:8080/api

# 应用配置
VITE_APP_TITLE=中医药数字信息平台
VITE_APP_VERSION=2.0.0

# 地图API密钥
VITE_MAP_API_KEY=your_amap_api_key

# 文件上传配置
VITE_UPLOAD_MAX_SIZE=100
VITE_UPLOAD_ALLOWED_TYPES=jpg,jpeg,png,pdf,doc,docx

# Neo4j Browser（开发调试用）
VITE_NEO4J_BROWSER_URL=http://localhost:7474
```

### A2. Docker部署配置

**docker-compose.yml**：

```yaml
version: '3.8'

services:
  # MySQL数据库
  mysql:
    image: mysql:8.0
    container_name: tcm-mysql
    environment:
      MYSQL_ROOT_PASSWORD: tcm123456
      MYSQL_DATABASE: tcm_platform
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql
      - ./sql:/docker-entrypoint-initdb.d
    command: --character-set-server=utf8mb4 --collation-server=utf8mb4_unicode_ci

  # Neo4j图数据库
  neo4j:
    image: neo4j:5.12
    container_name: tcm-neo4j
    environment:
      NEO4J_AUTH: neo4j/tcm123456
      NEO4J_PLUGINS: '["apoc", "graph-data-science"]'
    ports:
      - "7474:7474"
      - "7687:7687"
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs

  # Redis缓存
  redis:
    image: redis:7-alpine
    container_name: tcm-redis
    command: redis-server --requirepass tcm123456
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

  # 后端应用
  backend:
    build:
      context: ./backend
      dockerfile: Dockerfile
    container_name: tcm-backend
    environment:
      SPRING_PROFILES_ACTIVE: docker
    ports:
      - "8080:8080"
    depends_on:
      - mysql
      - neo4j
      - redis
    volumes:
      - ./logs:/app/logs
      - ./uploads:/app/uploads

  # 前端应用
  frontend:
    build:
      context: ./frontend
      dockerfile: Dockerfile
    container_name: tcm-frontend
    ports:
      - "80:80"
    depends_on:
      - backend

  # Nginx反向代理
  nginx:
    image: nginx:alpine
    container_name: tcm-nginx
    ports:
      - "443:443"
    volumes:
      - ./nginx/nginx.conf:/etc/nginx/nginx.conf
      - ./nginx/ssl:/etc/nginx/ssl
    depends_on:
      - frontend
      - backend

volumes:
  mysql_data:
  neo4j_data:
  neo4j_logs:
  redis_data:
```

### A3. 快速部署脚本

**deploy.sh**：

```bash
#!/bin/bash

echo "===== 中医药数字信息平台部署脚本 ====="

# 检查Docker环境
if ! command -v docker &> /dev/null; then
    echo "错误：未安装Docker"
    exit 1
fi

if ! command -v docker-compose &> /dev/null; then
    echo "错误：未安装Docker Compose"
    exit 1
fi

# 创建必要目录
mkdir -p logs uploads nginx/ssl

# 构建并启动服务
echo "正在构建Docker镜像..."
docker-compose build

echo "正在启动服务..."
docker-compose up -d

# 等待服务启动
echo "等待服务启动完成..."
sleep 30

# 检查服务状态
echo "检查服务状态..."
docker-compose ps

# 初始化数据
echo "初始化基础数据..."
docker-compose exec backend java -jar app.jar --spring.profiles.active=init

# 导入Neo4j数据
echo "导入知识图谱数据..."
docker-compose exec neo4j cypher-shell -u neo4j -p tcm123456 -f /var/lib/neo4j/import/init_knowledge_graph.cypher

echo "===== 部署完成 ====="
echo "Web端访问地址: http://localhost"
echo "API文档地址: http://localhost:8080/swagger-ui.html"
echo "Neo4j浏览器: http://localhost:7474"
echo ""
echo "默认管理员账号: admin"
echo "默认密码: admin123"
echo ""
echo "如需停止服务，请运行: docker-compose down"
```

### A4. 核心工具类

**知识图谱工具类**：

```java
@Component
public class KnowledgeGraphUtils {
    
    @Autowired
    private Neo4jTemplate neo4jTemplate;
    
    /**
     * 执行Cypher查询并返回结果
     */
    public List<Map<String, Object>> executeCypher(String cypher, Map<String, Object> params) {
        try {
            return neo4jTemplate.query(cypher, params);
        } catch (Exception e) {
            log.error("执行Cypher查询失败: {}", cypher, e);
            return Collections.emptyList();
        }
    }
    
    /**
     * 查找两个节点之间的最短路径
     */
    public List<Map<String, Object>> findShortestPath(String startNode, String endNode, String nodeType) {
        String cypher = """
            MATCH (start:%s {name: $startNode}), (end:%s {name: $endNode})
            MATCH path = shortestPath((start)-[*..5]-(end))
            RETURN nodes(path) as nodes, relationships(path) as relationships
            """.formatted(nodeType, nodeType);
        
        Map<String, Object> params = Map.of(
            "startNode", startNode,
            "endNode", endNode
        );
        
        return executeCypher(cypher, params);
    }
    
    /**
     * 获取节点的邻居信息
     */
    public List<Map<String, Object>> getNeighbors(String nodeName, String nodeType, int depth) {
        String cypher = """
            MATCH (n:%s {name: $nodeName})-[r*1..%d]-(neighbor)
            RETURN DISTINCT neighbor, r
            LIMIT 50
            """.formatted(nodeType, depth);
        
        return executeCypher(cypher, Map.of("nodeName", nodeName));
    }
    
    /**
     * 基于节点属性的相似度搜索
     */
    public List<Map<String, Object>> findSimilarNodes(String nodeName, String nodeType, double threshold) {
        String cypher = """
            MATCH (target:%s {name: $nodeName})
            MATCH (similar:%s)
            WHERE similar <> target
            WITH target, similar,
                 gds.similarity.cosine(
                     apoc.coll.toSet(split(target.effect, '，')),
                     apoc.coll.toSet(split(similar.effect, '，'))
                 ) as similarity
            WHERE similarity >= $threshold
            RETURN similar, similarity
            ORDER BY similarity DESC
            LIMIT 20
            """.formatted(nodeType, nodeType);
        
        Map<String, Object> params = Map.of(
            "nodeName", nodeName,
            "threshold", threshold
        );
        
        return executeCypher(cypher, params);
    }
}
```

**前端状态管理**：

```javascript
// stores/knowledge.js
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'

export const useKnowledgeStore = defineStore('knowledge', () => {
  // 状态
  const graphData = ref({ nodes: [], links: [] })
  const selectedNode = ref(null)
  const searchHistory = ref([])
  const loading = ref(false)
  
  // 计算属性
  const nodeCount = computed(() => graphData.value.nodes.length)
  const linkCount = computed(() => graphData.value.links.length)
  const hasData = computed(() => nodeCount.value > 0)
  
  // 方法
  const setGraphData = (data) => {
    graphData.value = data
  }
  
  const selectNode = (node) => {
    selectedNode.value = node
  }
  
  const addSearchHistory = (query) => {
    if (!searchHistory.value.includes(query)) {
      searchHistory.value.unshift(query)
      if (searchHistory.value.length > 10) {
        searchHistory.value = searchHistory.value.slice(0, 10)
      }
    }
  }
  
  const clearGraph = () => {
    graphData.value = { nodes: [], links: [] }
    selectedNode.value = null
  }
  
  const updateNodeData = (nodeId, newData) => {
    const nodeIndex = graphData.value.nodes.findIndex(n => n.id === nodeId)
    if (nodeIndex !== -1) {
      graphData.value.nodes[nodeIndex] = { ...graphData.value.nodes[nodeIndex], ...newData }
    }
  }
  
  return {
    // 状态
    graphData,
    selectedNode,
    searchHistory,
    loading,
    
    // 计算属性
    nodeCount,
    linkCount,
    hasData,
    
    // 方法
    setGraphData,
    selectNode,
    addSearchHistory,
    clearGraph,
    updateNodeData
  }
})
```

**前端API请求封装**：

```javascript
// utils/api.js
import axios from 'axios'
import { ElMessage } from 'element-plus'

// 创建axios实例
const api = axios.create({
  baseURL: import.meta.env.VITE_API_BASE_URL,
  timeout: 10000,
  headers: {
    'Content-Type': 'application/json'
  }
})

// 请求拦截器
api.interceptors.request.use(
  (config) => {
    // 添加token
    const token = localStorage.getItem('token')
    if (token) {
      config.headers.Authorization = `Bearer ${token}`
    }
    
    // 显示加载状态
    if (config.showLoading !== false) {
      // showLoading()
    }
    
    return config
  },
  (error) => {
    return Promise.reject(error)
  }
)

// 响应拦截器
api.interceptors.response.use(
  (response) => {
    // hideLoading()
    
    const { code, data, message } = response.data
    
    if (code === 200) {
      return data
    } else {
      ElMessage.error(message || '请求失败')
      return Promise.reject(new Error(message))
    }
  },
  (error) => {
    // hideLoading()
    
    if (error.response) {
      const { status, data } = error.response
      switch (status) {
        case 401:
          localStorage.removeItem('token')
          window.location.href = '/login'
          break
        case 403:
          ElMessage.error('权限不足')
          break
        case 404:
          ElMessage.error('资源不存在')
          break
        case 500:
          ElMessage.error('服务器错误')
          break
        default:
          ElMessage.error(data?.message || '网络错误')
      }
    } else {
      ElMessage.error('网络连接失败')
    }
    
    return Promise.reject(error)
  }
)

// 知识图谱相关API
export const knowledgeAPI = {
  // 搜索知识图谱
  search: (query, options = {}) => {
    return api.get('/knowledge-graph/search', {
      params: { q: query, ...options }
    })
  },
  
  // 获取节点详情
  getNodeDetail: (nodeId) => {
    return api.get(`/knowledge-graph/nodes/${nodeId}`)
  },
  
  // 获取节点关系
  getNodeRelations: (nodeId, depth = 2) => {
    return api.get(`/knowledge-graph/nodes/${nodeId}/relations`, {
      params: { depth }
    })
  },
  
  // 查找路径
  findPath: (startNode, endNode) => {
    return api.post('/knowledge-graph/path', {
      startNode,
      endNode
    })
  }
}

export default api
```

------

**总结**：本二阶段项目计划书提供了从需求分析到技术实现、从数据库设计到部署运维的完整解决方案。通过合理的模块划分、详细的技术设计和可行的实施计划，确保项目能够在7天内高质量完成，为中医药数字化发展贡献技术力量。